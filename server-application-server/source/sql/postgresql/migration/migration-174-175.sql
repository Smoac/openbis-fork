ALTER TABLE LINK_DATA ADD COLUMN DATA_FROZEN BOOLEAN_CHAR NOT NULL DEFAULT 'F';
ALTER TABLE LINK_DATA DROP CONSTRAINT lnda_data_fk;
ALTER TABLE LINK_DATA ADD CONSTRAINT lnda_data_fk FOREIGN KEY (ID, DATA_FROZEN) REFERENCES data_all(ID, FROZEN) ON DELETE CASCADE ON UPDATE CASCADE;
CREATE INDEX LINK_DATA_IDFRZ_PK_I ON LINK_DATA (ID, DATA_FROZEN);
ALTER TABLE LINK_DATA ADD CONSTRAINT LINK_DATA_IDFRZ_UK UNIQUE(ID, DATA_FROZEN);

ALTER TABLE CONTENT_COPIES ADD COLUMN DATA_FROZEN BOOLEAN_CHAR NOT NULL DEFAULT 'F';
ALTER TABLE CONTENT_COPIES DROP CONSTRAINT COCO_DATA_FK;
ALTER TABLE CONTENT_COPIES ADD CONSTRAINT COCO_DATA_FK FOREIGN KEY (DATA_ID, DATA_FROZEN) REFERENCES LINK_DATA(ID, DATA_FROZEN) ON UPDATE CASCADE;

CREATE OR REPLACE FUNCTION RAISE_EXCEPTION_FROZEN_LINK_DATA_SET() RETURNS trigger AS $$
DECLARE
    DATA_ID   TECH_ID;
BEGIN
    IF (TG_OP = 'DELETE') THEN
        DATA_ID = OLD.DATA_ID;
    ELSEIF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
        DATA_ID = NEW.DATA_ID;
    END IF;

    RAISE EXCEPTION 'Operation % CONTENT_COPY is not allowed because data set % is frozen.', TG_OP, 
        (select code from data_all where id = DATA_ID);
END;
$$ LANGUAGE 'plpgsql';


DROP TRIGGER IF EXISTS LINK_DATA_SET_FROZEN_CHECK_ON_INSERT ON CONTENT_COPIES;
CREATE TRIGGER LINK_DATA_SET_FROZEN_CHECK_ON_INSERT BEFORE INSERT ON CONTENT_COPIES
    FOR EACH ROW WHEN (NEW.DATA_FROZEN)
    EXECUTE PROCEDURE RAISE_EXCEPTION_FROZEN_LINK_DATA_SET();

DROP TRIGGER IF EXISTS LINK_DATA_SET_FROZEN_CHECK_ON_DELETE ON CONTENT_COPIES;
CREATE TRIGGER LINK_DATA_SET_FROZEN_CHECK_ON_DELETE BEFORE DELETE ON CONTENT_COPIES
    FOR EACH ROW WHEN (OLD.DATA_FROZEN)
    EXECUTE PROCEDURE RAISE_EXCEPTION_FROZEN_LINK_DATA_SET();
    