<html>
<head>
  <title>openBIS BaSynthec Browser</title>
  <link type="text/css" rel="stylesheet" href="body-style.css" />
  <link type="text/css" rel="stylesheet" href="button.css" />
  <link type="text/css" rel="stylesheet" href="tree.css" />
  <script type="text/javascript" src="d3.js"></script>
  <script type="text/javascript" src="d3.layout.js"></script>
  <script type="text/javascript" src="d3.time.js"></script>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="openbis.js"></script>
  <script type="text/javascript" src="openbis-basynthec.js"></script>
  <!-- To speed development, cache the requests -->
  <script type="text/javascript" src="openbis-request-cache.js"></script>
  <script>

basynthec = new openbis_basynthec('https://basynthec.ethz.ch/openbis/openbis', 'https://basynthec.ethz.ch/datastore_server');

var w = 840, h = 2400;
// N.b. Height and width are swapped in the tree
var tree = d3.layout.tree().size([h, w - 340]);

// A helper function for drawing the lines between nodes
var diagonal = d3.svg.diagonal().projection(function(d) { return [d.y, d.x] });	

// The tree visualization
var vis;

// The node inspectors
var inspectors;

// The root of the tree
var root = { name : "BaSynthec", children : [] };

// The inspected elements
var inspected = [];

// A date formatter for grouping samples by registration year / month
var yearmonthformat = d3.time.format("%Y-%m");

var IGNORED_DATASET_TYPES = [ "EXCEL_ORIGINAL", "TSV_EXPORT", "UNKNOWN" ];


/**
 * Return true if the selected display mode is "Strain", false otherwise.
 */
function isStrainDisplayMode() {

	return "strain" == $('input[name=displayMode]:checked').val()
}

/**
 * Finds and returns a single element within an array
 * which satisfies a given filter function. 
 */
function findInArray(array, filter) {
	for (var i = 0; i < array.length; i++) 
	{
		if (filter(array[i]))
			return array[i];
	}
	return null;
}

/**
 * Depending on the selected display mode (STRAIN or TYPE) returns a 
 * a list of tuples [node1, node2] with each entry representing a unique 
 * path in the tree where the given data set should be placed.
 */
function extractTreePaths(dataSet) 
{
	var extractorFun = isStrainDisplayMode() 
	  ? function(strain) { return [strain, dataSet.dataSetTypeCode]; }
	  : function(strain) { return [dataSet.dataSetTypeCode, strain]; };
	
	return basynthec.getStrains(dataSet).map(extractorFun);
}

function addDataSet(node, path, dataSet) {
  if (path.length == 0) 
  {
	  node.children.push({ name: dataSet.code, bisDataSet:dataSet });
  }	
  else 
  {
	  var nextNodeName = path.shift()
	  var nextNode = findInArray(node.children, function(child) { return child.name == nextNodeName } );
	  if (nextNode == null) 
	  {
		  nextNode = { name:nextNodeName, children:[] };
		  node.children.push(nextNode)
    } 
	  addDataSet(nextNode, path, dataSet)
  }
}

/**
 * refreshes the view based on the selected display mode. 
 */
function refreshTree() {
	
	var tempRoot = { children: [] };
	
	basynthec.dataSetList.forEach(function(dataSet) {
		  
    var treeLocations = extractTreePaths(dataSet);
    treeLocations.forEach(function(path) {
    	  addDataSet(tempRoot, path, dataSet);
    });
		
	})
	
	root.children = tempRoot.children;
	
	showTree();
 	updateDiagram(1000);			
}
 
/**
 * Shows the list of data sets retrieved from the openBIS server.
 */
function showDataSets(bisDataSets)
{
	if (null == bisDataSets) return;
	
	basynthec.dataSetList = bisDataSets.filter(function(dataSet) { 
		return IGNORED_DATASET_TYPES.indexOf(dataSet.dataSetTypeCode) == -1;
  });
	
	refreshTree();
}

function showTree()
{	
	// Don't show anything yet, just initialize the visualization
	createVis();
}

var didCreateVis = false;

/**
 * Create the DOM elements to store the visualization (tree + inspectors)
 */
function createVis()
{
	if (didCreateVis) return;
	
	// Create a div to house the tree visualization and the inspectors
	visgroup = d3.select("#main").append("div");
	visgroup.style("width", "" + (w + 400) + "px")
	
	// An svg element for the tree visualization
	vis = visgroup.append("svg:svg")
		.attr("width", w)
		.attr("height", h)
	.append("svg:g")
		.attr("transform", "translate(40, 0)");
	
	// An element for the inspectors.
	inspectors = visgroup.append("span")
		.style("width", "400px")
		.style("position", "relative")
		.style("overflow", "auto")
		.style("float", "right")
		.style("left", "20px");
		
	didCreateVis = true;
}


/**
 * Draw / update the tree
 */
function updateDiagram(duration)
{	
	// Update the tree and compute the new layout
	var nodes = tree.nodes(root);

	// Draw / update the links	
	var link = vis.selectAll("path.link").data(tree.links(nodes), function(d) { return d.name });
	
	link.enter().append("svg:path")
			.attr("class", "link")
			.attr("d", function(d) {
				var y0 = (null != d.source.y0) ? d.source.y0 : d.source.y; 
				var x0 = (null != d.source.x0) ? d.source.x0 : d.source.x;
				var o = {x: x0, y: y0};
				return diagonal({source: o, target: o});
			})
		.transition()
			.duration(duration)
			.attr("d", diagonal);
		
	link.transition()
		.duration(duration)
		.attr("d", diagonal);
		
	link.exit().transition()
		.duration(duration)
		.attr("d", function(d) {
				var y0 = (null != d.source.y0) ? d.source.y0 : d.source.y; 
				var x0 = (null != d.source.x0) ? d.source.x0 : d.source.x;
				var o = {x: x0, y: y0};
				return diagonal({source: o, target: o});
			})
		.remove();

	// Draw / update the nodes
	var node = vis.selectAll("g.node").data(nodes, function(d) { return d.name });
	
	var nodeEnter = 
		node.enter().append("svg:g")
			.attr("class", classForNode)
			.attr("transform", translateSrc)
			.on("click", toggle_open);

	nodeEnter.append("svg:circle")
		.attr("r", 5.5);

	nodeEnter.append("svg:text")
		.attr("dx", function(d) { return hasChildren(d) ? -8 : 8 })
		.attr("dy", 3)
		.attr("text-anchor", function(d) { return hasChildren(d) ? "end" : "start" })
		.text(function(d) { return d.name });

	nodeEnter
		.transition()
			.duration(duration)
			.attr("transform", translateDst);
		
	
	// Transition nodes to their new position.
	node.transition()
		.duration(duration)
		.attr("class", classForNode)
		.attr("transform", translateDst);

	// Move the text elements to the appropriate position
	node.selectAll("text").transition()
		.duration(duration)
		.attr("dx", function(d) { return hasChildren(d) ? -8 : 8 })
		.attr("text-anchor", function(d) { return hasChildren(d) ? "end" : "start" });
		
	node.exit().transition()
		.duration(duration)
		.attr("transform", translateSrc)
		.remove();
}

function classForNode(d) { 
	// Use whether the node has open children or not to compute the class
	var cssClass = hasChildren(d) ? "node withchildren" : "node leaf";
	if (d.inspected) cssClass = cssClass + " inspected";
	if (d.flowlanes && d.flowlanes.length > 0) cssClass = cssClass + " sequenced";

	return cssClass;
}

function translateSrc(d)
{
	var translate;
	if (d.parent != undefined) {
		var y0 = (null != d.parent.y0) ? d.parent.y0 : d.parent.y;
		var x0 = (null != d.parent.x0) ? d.parent.x0 : d.parent.x;
		translate = "translate(" + y0 + "," + x0 + ")";
	} else {
		translate = "translate(" + 0 + "," + 0 + ")";
	}
	
	return translate;
}

function translateDst(d)
{
	d.x0 = d.x;
	d.y0 = d.y;
	var translate =  "translate(" + d.y + "," + d.x + ")";
	
	return translate;
}

function hasChildren(d)
{
	return d.children != null || d._children != null;
}

function hasOpenChildren(d)
{
	return d.children != null;
}

// Toggle children on click.
function toggle_open(d) {
	if (!hasChildren(d)) {
		d.svgNode = this;
		return toggle_inspected.call(this, d);
	}
	
  if (d.children) {
    d._children = d.children;
    d.children = null;
  } else {
    d.children = d._children;
    d._children = null;
  }
  updateDiagram(500);
}

/**
 * Draw / update node inspectors
 */
function updateInspectors(duration)
{	
		// Draw / update the inspectors	
	var inspector = inspectors.selectAll("div.inspector").data(inspected, function (d) { return d.name });
	var box = inspector.enter().append("div")
		.attr("class", "inspector")
		.text(function(d) { return d.name });
		
	box.append("span")
		.attr("class", "close")
		.on("click", toggle_inspected)
		.text("x");
		
	var propsTable = box.append("table").attr("class", "properties");
	propsTable.selectAll("tr").data(function(d) { return props_to_pairs(d.bis.properties) })
		.enter()
			.append("tr")
			.selectAll("td").data(function(d) { return d }).enter()
				.append("td")
				.attr("class", "property")
				.style("opacity", "0")
				.text(function(d) { return d })
			.transition()
				.style("opacity", "1");
				
	var downloadTable = box.append("table");
	downloadTable
		.attr("width", "100%")
		.attr("class", "downloads")
		.style("color", "steelblue");
			
	// Add a caption, but make sure there is just one (this does not work with select())
	downloadTable.selectAll("caption")
			.data(downloadTableCaption)
		.enter()
			.append("caption").text(function(d) { return d; });
	var downloadTableRow = 
		downloadTable.selectAll("tr")
			.data(function(d) { return (d.flowlanes) ? d.flowlanes : [] })
		.enter()
			.append("tr");
	downloadTableRow
		.append("td")
			.style("text-align", "left")
			.text("metadata.tsv");
	downloadTableRow
		.append("td")
			.style("border-right", "0px")
			.style("text-align", "right")
			.text("fastq.gz");
		
	inspector.exit().transition()
		.duration(duration)
		.style("opacity", "0")
		.remove();
}

// Toggle children on click.
function toggle_inspected(d) {
	if (d.inspected) {
		var index = inspected.indexOf(d) 
		if (index > -1)	inspected.splice(index, 1);
		d.inspected = false;
		d3.select(d.svgNode).attr("class", classForNode(d))
	} else {
		d.inspected = true;
		inspected.push(d);
		d3.select(d.svgNode).attr("class", classForNode(d))
		retrieveFilesForSequencingSample(d);
	}
  updateInspectors(500);
}

/**
 * Convert properties to pairs
 */
function props_to_pairs(d)
{
	var pairs = [];
	for (var prop in d) {
		var pair = [prop, d[prop]];
		pairs.push(pair);
	}
	pairs.sort(function(a, b) { 
		if (a[0] == b[0]) return 0;
		// Sort in reverse lexicographical
		return (a[0] < b[0]) ? -1 : 1;
	});
	return pairs;
}

function enterApp()
{
	$("#login-form-div").hide();
	$("#main").show();
	basynthec.listAllDataSets(function(data) { 
		showDataSets(data.result); 
	});
}

function groupNames()
{
	var strainNames = root.children[3].children.map(function(strain) { return strain.name.replace("JJS-MGP", "").replace("JJS-DIN","") }).sort();
	return strainNames.reduce(reduceNames, []);
}

function reduceNames(groups, name) 
{ 
	if (groups.length < 1) {
		groups.push([name]);
		return groups;
	}
	
	var lastGrp = groups[groups.length - 1];
	var lastElt = lastGrp[lastGrp.length - 1];
	if (lastElt == name) return groups;
	
	if (lastElt.charAt(0) == name.charAt(0)) 
		lastGrp.push(name); 
	else 
		groups.push([name]);

	return groups;
}


$(document).ready(function() {
	$("#main").hide()
	
	$('#logout-button').click(function() { basynthec.server.logout(function(data) {}) });
	
	$('#login-form').submit(function() {
	  basynthec.server.login( $('#username').val(), $('#password').val(), function(data) { enterApp() })
	});
	
	$('#login-form').submit(function() {
	  basynthec.server.login( $('#username').val(), $('#password').val(), function(data) { enterApp() })
	});

	$("input[name=displayMode]").change( function() {
		refreshTree();
	});	
	
	basynthec.server.ifRestoredSessionActive(function(data) { enterApp() });
 });
 
 </script>
</head>
<body>

<div id="login-form-div">
<h1>openBIS BaSynthec</h1>

<form id="login-form" action="javascript:">
<input id="username" type="text"> <input id="password" type="password"> <button id="login-button">Login</button>
</form>
</div>

<div id="main">

<div id="button-group">
	<button id="logout-button">Logout</button>
</div>

<div id="display-mode">
	<form id="display-mode-form">
		<input type="radio" name="displayMode" value="strain" checked="checked">Strain
		&nbsp;
		<input type="radio" name="displayMode" value="type">Type
	</form>
</div>

<div id="filter-div">
  Filter <input type="text" id="filter-box" value=""/>
</div>

</div>

</body>
</html>