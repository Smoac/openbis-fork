#!/usr/bin/env ruby

require 'rubygems'
require 'json'
require 'pp'
require 'set'

#
# = A wrapper for scripting jira
#
# Try the following commands:
#
#   jira sprint S133  [lists the tasks in S133]
#   jira plan S134    [shows the tasks planned for S134 in a form suitable for planning]
#
# Uses the Rest API: http://docs.atlassian.com/jira/REST/4.2.1/
#
# ----
# 
# This script requires the json gem:
#
#    http://flori.github.com/json/
#
# Which can be installed:
#
#   gem install json
#

#
# == Preferences
#

# The url for JIRA
$jira_url = 'https://jira-bsse.ethz.ch'

# The url portion for the API
#$jira_api_url = "#{$jira_url}/rest/api/2.0.alpha1"
$jira_api_url = "#{$jira_url}/rest/api/2"

# Prefs path
$jira_prefs_path = File.expand_path('~/.jira')

# Cookie location
$jira_cookie_path = File.join($jira_prefs_path, 'cookie.txt')


# 
# == Issue Object
#
class Issue
  
  def initialize(data)
    @issue = data
  end
  
  def key
    return @issue["key"]
  end
  
  def fields
    return @issue["fields"]
  end
  
  def implements
    implements = nil
    links = self.fields["issuelinks"]
    unless links.nil?
      links.each { | link | implements =  Issue.new(link["outwardIssue"]) if "implements" == link["type"]["outward"] && !link["outwardIssue"].nil? }
    end

    return implements
  end
  
  def implemented_by
    implementedby = []
    links = self.fields["issuelinks"]
    unless links.nil?
      links.each { | link | implementedby << Issue.new(link["inwardIssue"]) if "implements" == link["type"]["outward"] && !link["inwardIssue"].nil?}
    end
    return implementedby
  end
  
  def time
    return 0 if self.fields["timetracking"].nil?
    return self.fields["timetracking"]["remainingEstimateSeconds"] ? self.fields["timetracking"]["remainingEstimateSeconds"] : 0
  end
  
  def status
    return self.fields["status"] ? self.fields["status"]["name"] : nil
  end
  
  def tester
    return self.fields["customfield_10250"] ? self.fields["customfield_10250"]["name"] : nil
  end
  
  def summary
    return self.fields["summary"]
  end
  
  def fix_version
    fix_versions = self.fields["fixVersions"]
    return "Unscheduled" if fix_versions.nil?
    return fix_versions[0]["name"]
  end
end


#
# A module that implements some helpful operations
#
module JiraHelpers
  def JiraHelpers.args(first_arg)
    cmd = ARGV[first_arg .. -1].inject("") { | all, each | all + " " + each }
    cmd.strip!
    return cmd
  end
  
  def JiraHelpers.search(query, limit=nil)
    search_cmd = "curl -s --get --cookie #{$jira_cookie_path} '#{$jira_api_url}/search' --data-urlencode 'jql=#{query}' --data-urlencode 'fields=*all,-comment'"
    search_cmd = search_cmd + " --data-urlencode 'maxResults=#{limit}'" unless limit.nil?
    return `#{search_cmd}`
  end
  
  def JiraHelpers.rank(issue, after, before=nil)
    rank_data = {"issueKeys" => [issue], "customFieldId" => 10050 }
    rank_data["rankAfterKey"] = after
    rank_data["rankBeforeKey"] = before unless before.nil?    
    rank_cmd = "curl -s --cookie #{$jira_cookie_path} -H 'Content-Type: application/json' '#{$jira_url}/rest/greenhopper/1.0/rank' -d '#{JSON.generate(rank_data)}'"
    puts rank_cmd
    return `#{rank_cmd}`
  end  

  # Search and return the full data for the found objects
  def JiraHelpers.search_full(query, silent)
    print "Retrieving issues" unless silent
    ans = JiraHelpers.search(query)
    data = JSON.load(ans)
    full_issues_data = data["issues"]
    full_issues = full_issues_data.collect { | issue_data | Issue.new(issue_data) }
    print "\n" unless silent   
    return full_issues
  end
  
  # Get the full data for entries that implement {issues}.
  def JiraHelpers.retrieve_implementors(issues, silent)
    print "Retrieving implementing issues" unless silent
    implementors = []
    issues.each do | issue |
      print "." unless silent
      implementors.concat issue.implemented_by
    end
        
    print "\n" unless silent   
    return implementors
  end  
  
  def JiraHelpers.session_valid?
    # Just get the response code, don't care about the rest
    ans = `curl -s -w %{http_code} -o /dev/null --head --get --cookie #{$jira_cookie_path} '#{$jira_url}/rest/auth/1/session'`
    return false if $?.to_i != 0
    return ans == "200"
  end
end


#
# == Commands
#

#
# The abstract superclass of commands
# 
class JiraCommand
  
  attr_accessor :silent
  
  def initialize
    @silent = true
  end
  
  # Return a description of the command to run
  def description
    return nil
  end
  
  # Run the command and return the result
  def run
    return nil
  end

  # Return true if the result should be printed. 
  #
  # Default: print if the result is not empty.
  def should_print_result(result)
    return !result.empty? 
  end
  
end

#
# The help command
#
class Help < JiraCommand
  def description
    return "help"
  end
  
  def run
    # show help
return <<-eos
NAME
    jira

SYNOPSIS
    jira commmand [arguments]

DESCRIPTION
    A simple api for jira. Login as jira user and get some info. The available commands are:    

	login	asks for login and password to jira and stores a session cookie

	sprint S133	get the information about the given sprint

	dump url	print given url in pure json

	plan S133	shows planned BIS issues

	cust 10	shows an overview of the N highest-priority issues from customer projects (OBP, SOB)
  eos
  end
end

#
# The login command
#
class Login < JiraCommand
 
  def initialize
    super
    print "Enter jira login (e.g. alincoln): "
    @jira_user = $stdin.gets().strip
  end
 
  def description
    return "login"
  end
  
  def run
    # The url portion for logging in
    # may also want to try curl -c cookie_jar -H "Content-Type: application/json" -d '{"username" : "admin", "password" : "admin"}' #{$jira_url}/jira/rest/auth/latest/session
    jira_login = 'secure/Dashboard.jspa?os_authType=basic'
    Dir.mkdir($jira_prefs_path) unless File.exists?($jira_prefs_path)
    return `curl --head -s -u #{@jira_user} --cookie-jar #{$jira_cookie_path} '#{$jira_url}/#{jira_login}'`
  end
end

#
# Lists the issues in the sprint
#
class LoggedInCommand < JiraCommand
  def run
    Login.new.run unless File.exists?($jira_cookie_path)
    Login.new.run unless JiraHelpers.session_valid?
    return self.run_logged_in
  end

  # For subclasses to implement
  def run_logged_in
    return ""
  end
end

#
# Shows the JSON for an issue -- useful for debugging
#
class DumpIssue < LoggedInCommand
  def initialize
    super
    @issueUrl = ARGV[1]
  end
  
  def description
    return "dump #{@issueUrl}"
  end
  
  
  def run_logged_in
    if @issueUrl.nil?
      ans =  JiraHelpers.search("project=SP AND fixVersion = S133 ORDER BY \"Global Rank\" ASC")
      @issueUrl = JSON.load(ans)["issues"][0]["self"]
    end

    ans = `curl -s --get --cookie #{$jira_cookie_path} '#{@issueUrl}'`
    data = JSON.load(ans)
    return JSON.pretty_generate(data)
  end
  
end

#
# Prioritize an issue
#

# The REST API can be browsed using the REST endpoint browser. The particular endpoint you are looking for is a PUT request to /rest/greenhopper/1.0/rank. The request body looks # like: 

# {"issueKeys":["ANERDS-102"],"rankBeforeKey":"ANERDS-94","rankAfterKey":"ANERDS-7","customFieldId":10050}
# The issueKeys are the items to rank (there can be several), the rankBeforeKey is the issue to rank the items before and the rankAfterKey is the issue to rank these items after. # Because there may be multuple Global Rank fields in your JIRA the customFieldId is used to specify which one is used for this ranking.

    # "customfield_10050": {
    #   "required": false,
    #   "schema": {
    #     "type": "array",
    #     "items": "string",
    #     "custom": "com.pyxis.greenhopper.jira:gh-global-rank",
    #     "customId": 10050
    #   },
    #   "name": "Global Rank",
    #   "operations": ["set"]
    # },
class RankIssue < LoggedInCommand
  def initialize
    super
    @issue = ARGV[1]
    @after = ARGV[2]
    @before = ARGV[3]
  end
  
  def description
    return "rank #{@issue} after #{@after} before #{@before}"
  end
  
  
  def run_logged_in
    ans = JiraHelpers.rank(@issue, @after, @before)
    return ans
  end
  
end

#
# Shows the JSON for a search results -- useful for debugging
#
class DumpSearch < LoggedInCommand
  def initialize
    super
    @query = ARGV[1]
    @count = ARGV[2]
  end
  
  def description
    return "search #{@query} #{@count}"
  end
  
  
  def run_logged_in
    @query = "project=SP AND fixVersion = S139 ORDER BY \"Global Rank\" ASC" if @query.nil?
    @count = 1 if @count.nil?

    ans = JiraHelpers.search(@query, @count)
    data = JSON.load(ans)
    return JSON.pretty_generate(data)
  end
  
end

#
# Lists the issues in the sprint
#
class ListSprint < LoggedInCommand
  def initialize
    super
    @sprintNumber = ARGV[1]
    @sprintNumber = "S" if @sprintNumber.nil?
    @sprintNumber = "S" + @sprintNumber unless @sprintNumber.match("^[S|s].*")
  end
  
  def description
    return "sprint #{@sprintNumber}"
  end
  
  
  def run_logged_in
    query = "project=SP AND fixVersion = #{@sprintNumber} ORDER BY \"Global Rank\" ASC" 
    full_issues = JiraHelpers.search_full(query, @silent)
    self.print_issues_table(full_issues)
    # Nothing to show
    return "#{full_issues.length} issues"
  end
  
  def print_issues_table(full_issues)
    header = "%8s\t%12s\t%6s\t%12s\t%8s\t%s" % ["Key", "Implements", "Time", "Status", "Tester", "Summary"]
    puts header
    time_remaining = 0.0
    full_issues.each do | issue |
      key = issue.key
      implements_key = issue.implements.key unless issue.implements.nil?
      time = issue.time
      status = issue.status
      tester = issue.tester
      summary = issue.summary
      row = "%8s\t%12s\t%5.1fh\t%12s\t%8s\t%s" % [key, implements_key, time / 3600.0, status, tester, summary]
      puts row
      
      # Tasks that are resolved can be considered to have 0 time remaining
      time_remaining = time_remaining + time unless (status == "Resolved" || status == "Closed")
    end
    print " ", ("-" * 27), "\n"
    puts "   Time Remaining : %.1fh" % (time_remaining / 3600.0)
  end
end

#
# List the issues slated for a sprint in a form that is helpful for planning
#
class PlanSprint < LoggedInCommand
  def initialize
    super
    @sprintNumber = ARGV[1]
    @sprintNumber = "S" if @sprintNumber.nil?
    @sprintNumber = "S" + @sprintNumber unless @sprintNumber.match("^[S|s].*")
  end
  
  def description
    return "plan #{@sprintNumber}"
  end
  
  
  def run_logged_in
    sp_query = "project=SP AND fixVersion = #{@sprintNumber} ORDER BY \"Global Rank\" ASC" 
    sp_issues = JiraHelpers.search_full(sp_query, @silent)
    init_sp_issue_dict(sp_issues)
    
    bis_query= "project = BIS AND status not in (Resolved, Closed) AND \"Next Sprint\" = YES ORDER BY \"Global Rank\" ASC"
    bis_issues = JiraHelpers.search_full(bis_query, @silent)
    enrich_sp_issue_dict(JiraHelpers.retrieve_implementors(bis_issues, @silent))
    
    ccs_query= "project = CCS AND status not in (Resolved, Closed) AND \"Next Sprint\" = YES ORDER BY \"Global Rank\" ASC"
    ccs_issues = JiraHelpers.search_full(ccs_query, @silent)
    enrich_sp_issue_dict(JiraHelpers.retrieve_implementors(ccs_issues, @silent))    
    
    swe_query= "project = SWE AND status not in (Resolved, Closed) AND \"Next Sprint\" = YES ORDER BY \"Global Rank\" ASC"
    swe_issues = JiraHelpers.search_full(swe_query, @silent)
    enrich_sp_issue_dict(JiraHelpers.retrieve_implementors(swe_issues, @silent))
    
    print_issues_table("BIS", bis_issues)
    print_issues_table("CCS", ccs_issues)    
    print_issues_table("SWE", swe_issues)    
    print_unseen_sp_issues_table(sp_issues)

    # Nothing to show
    issue_count = bis_issues.length + ccs_issues.length + swe_issues.length
    return "#{issue_count} issues"
  end
  
  def init_sp_issue_dict(sp_issues)
    @sp_issue_dict = {}
    sp_issues.each do | issue |
      key = issue.key
      @sp_issue_dict[key] = issue
    end
    @seen_sp_issues = [].to_set
  end
  
  #
  # Take those issues that are not yet resolved / closed and add them to the sp issues dict
  #
  def enrich_sp_issue_dict(implementors)
    implementors.each do | issue |
      sp = issue.key
      next if @sp_issue_dict[sp]
      
      status = issue.status
      @sp_issue_dict[sp] = issue_dict unless (status == "Resolved" || status == "Closed")
    end 
  end  
  
  def print_unseen_sp_issues_table(full_issues)
    puts ("=" * 12)
    puts "SP Missed"
    puts ("-" * 12)
    header = "%8s\t%12s\t%12s\t%6s\t%s" % ["Subtotal", "Key", "SP", "Time", "Summary"]
    puts header
    subtotal = 0.0
    full_issues.each do | issue |
      sp = issue.key
      next if @seen_sp_issues.include?(sp)
      
      key = "----"
      key = issue.implements.key unless issue.implements.nil?
      time = issue.time
      summary = issue.summary
      # Tasks that are resolved can be considered to have 0 time remaining
      status = issue.status
      subtotal = subtotal + time unless status == "Resolved"
      row = "%8.1fh\t%12s\t%12s\t%5.1fh\t%s" % [subtotal / 3600.0, key, sp, time / 3600.0, summary]
      puts row
    end
  end
  
  def print_issues_table(title, full_issues)
    puts ("=" * 12)
    puts title
    puts ("-" * 12)
    header = "%8s\t%12s\t%12s\t%6s\t%s" % ["Subtotal", "Key", "SP", "Time", "Summary"]
    puts header
    subtotal = 0.0
    full_issues.each do | issue |
      key = issue.key
      summary = issue.summary
      parent = issue.fields["parent"]
      parent = parent["key"] unless parent.nil?
      summary = "#{parent} / #{summary}" unless parent.nil?
            
      implementedby = []
      issue.implemented_by.each do | sp_issue |
        sp = sp_issue.key
        # We are only interested in links to issues in the specified sprint
        implementedby << sp if @sp_issue_dict[sp]
      end
      
      if implementedby.length < 1
        row = "%8s\t%12s\t%12s\t%5.1fh\t%s" % ["----", key, "----", 0, summary]
        puts row
        next
      end
      
      implementedby.each_with_index do | sp, index |
        # print one row for each implemented by
        spissue = @sp_issue_dict[sp]
        next if spissue.nil?
        next if @seen_sp_issues.include?(sp)
        
        spfields = spissue.fields
        time = spissue.time

        # Tasks that are resolved can be considered to have 0 time remaining
        fix_version = spissue.fix_version
        issue_in_different_sprint = fix_version != @sprintNumber
        status = spissue.status       
        subtotal = subtotal + time unless (status == "Resolved" || status == "Closed" || issue_in_different_sprint)
        if index < 1 
          issue_summary = summary
          issue_summary =  "[#{fix_version}] #{issue_summary}" if issue_in_different_sprint
          row = "%8.1fh\t%12s\t%12s\t%5.1fh\t%s" % [subtotal / 3600.0, key, sp, time / 3600.0, issue_summary]
        else
          issue_summary = "\""
          issue_summary =  "[#{fix_version}] #{issue_summary}" if issue_in_different_sprint
          row = "%8.1fh\t%12s\t%12s\t%5.1fh\t%s" % [subtotal / 3600.0, "\"", sp, time / 3600.0, issue_summary]
        end
        puts row
        @seen_sp_issues.add(sp)
      end
    end
  end  
end

#
# List the issues slated from customer projects
#
class CustIssues < LoggedInCommand
  def initialize
    super
  end
  
  def description
    return "cust"
  end
  
  
  def run_logged_in
    obp_query = "project=OBP AND status not in (Resolved, Closed) ORDER BY \"Global Rank\" ASC"
    obp_issues = JiraHelpers.search_full(obp_query, @silent)
    
    sob_query = "project=SOB AND status not in (Resolved, Closed) ORDER BY \"Global Rank\" ASC"
    sob_issues = JiraHelpers.search_full(sob_query, @silent)
    
    all_issues = [obp_issues, sob_issues].flatten
    implementors = JiraHelpers.retrieve_implementors(all_issues, @silent)
    init_implementors_dict(implementors)
    
    print_issues_table("OBP", obp_issues)
    print_issues_table("SOB", sob_issues)
    
    # Nothing to show
    return "#{all_issues.length} issues"
  end
  
  def init_implementors_dict(implementors)
    @implementors_dict = {}
    implementors.each do | issue |
      key = issue["key"]
      @implementors_dict[key] = issue
    end
  end
  
  def print_issues_table(title, full_issues)
    puts ("=" * 12)
    puts title
    puts ("-" * 12)
    header = "%12s\t%12s\t%s" % ["Key", "BIS", "Summary"]
    puts header
    full_issues.each do | issue |
      key = issue["key"]
      fields = issue["fields"]
      summary = fields["summary"]["value"]
            
      implementedby = []
      fields["links"]["value"].each do | link | 
        implementor = link["issueKey"]
        # We are only interested in links to issues in the specified sprint
        next unless @implementors_dict[implementor]
        implementedby << implementor if "is implemented by" == link["type"]["description"] 
      end
      
      if implementedby.length < 1
        row = "%12s\t%12s\t%s" % [key, "----", summary]
        puts row
        next
      end
      
      implementedby.each_with_index do | implementor, index |
        # print one row for each implemented by
        implementorissue = @implementors_dict[implementor]
        next if implementorissue.nil?
        implementorfields = implementorissue["fields"]
        time = 0        
        time = implementorfields["timetracking"]["value"]["timeestimate"] if implementorfields["timetracking"]["value"] != nil
        if index < 1 
          row = "%12s\t%12s\t%s" % [key, implementor, summary]
        else
          row = "%12s\t%12s\t%s" % ["\"", implementor, "\""]
        end
        puts row
      
        # Tasks that are resolved can be considered to have 0 time remaining
        status = implementorfields["status"]["value"]["name"]
      end
    end
  end  
end



def get_command
  return Help.new if ARGV.length < 1
  
  ans = case ARGV[0]
  when "login" then Login.new
  when "sprint" then ListSprint.new
  when "dump" then DumpIssue.new
  when "search" then DumpSearch.new
  when "plan" then PlanSprint.new
	when "cust" then CustIssues.new
	when "rank" then RankIssue.new
  else Help.new
  end

  return ans  
end


#
# == Main logic
# 
cmd = get_command

result = cmd.run

if cmd.should_print_result(result)
  puts result
end
