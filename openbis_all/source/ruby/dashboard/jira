#!/usr/bin/env ruby

require 'rubygems'
require 'json'
require 'pp'
require 'set'
require './jirarb/core'
require './jirarb/debug'
require './jirarb/kanban'

#
# = A wrapper for scripting jira
#
# Try the following commands:
#
#   jira sprint S133  [lists the tasks in S133]
#   jira plan S134    [shows the tasks planned for S134 in a form suitable for planning]
#
# Uses the Rest API: http://docs.atlassian.com/jira/REST/4.2.1/
#
# ----
# 
# This script requires the json gem:
#
#    http://flori.github.com/json/
#
# Which can be installed:
#
#   gem install json
#

#
# == Preferences
#

# The url for JIRA
$jira_url = 'https://jira-bsse.ethz.ch'

# The url portion for the API
#$jira_api_url = "#{$jira_url}/rest/api/2.0.alpha1"
$jira_api_url = "#{$jira_url}/rest/api/2"

# Prefs path
$jira_prefs_path = File.expand_path('~/.jira')

# Cookie location
$jira_cookie_path = File.join($jira_prefs_path, 'cookie.txt')




#
# The help command
#
class Help < JiraCommand
  def description
    return "help"
  end
  
  def run
    # show help
return <<-eos
NAME
    jira

SYNOPSIS
    jira commmand [arguments]

DESCRIPTION
  A simple api for jira. Login as jira user and get some info. The available commands are:    

	login
        asks for login and password to jira and stores a session cookie
	
	session
        check if the session cookie is still valid

  dump url
        print given url in pure json 

	sprint 133
        get the information about the given sprint

	plan 133
        shows planned BIS issues

	cust 10
        shows an overview of the N highest-priority issues from customer projects (OBP, SOB)
	
	search 'project=SP AND fixVersion = S139 ORDER BY \"Global Rank\"' 
				runs a jira query and shows the results
	
	rank 133 	ranks all issues in S133 in accordance with the ranks of the BIS issues	
	rank SP-121 SP-122
				ranks SP-121 after SP-122
				
	kanban1304 133
        returns a Kanban list of the issues in S133 designated for the 1304 release
	
	create 133
        create issues for all BIS issues designated as next sprint	
	create 133 BIS-111
				create an issue in S133 for BIS-111

	start 133
        mark all BIS issues in S133 as "Active in sprint" and clear the "Next Sprint" flag
	
	finish 133
        Show whether the parent issues to those in S133 are resolved or not				
	finish 133 exec	
        mark all BIS issues in S133 that have no other open issues as resolved. 
				Set "Next Sprint" for those with open issues.
				
	move 133
        Set the fix version to 133 for all issues that are connected to the BIS issues
	move 133 SP-452
        Set the fix version of SP-452 to 133
	
	fix-add 13.04.1  BIS-111
        Add the fix version of 13.04.1 to BIS-111
	fix-add 13.04.1  BIS-111,BIS-112,BIS-113
        Add the fix version of 13.04.1 to BIS-111, BIS-112, and BIS-113
	
	port1304 155
        returns a list of issues that need to be ported to the release branch
	port1304 155 commit
        returns a list of commits that need to be ported to the release branch
  
  report 166
        returns a table of how much each employee worked for each beneficiary

  benefit	166
        shows the beneficiaries for all the issues in the sprint

  setup 173
        Ensure that the version number exists and create the standard tasks for the sprint
  eos
  end
end


#
# Prioritize an issue
#

# The REST API can be browsed using the REST endpoint browser. The particular endpoint you are looking for is a PUT request to /rest/greenhopper/1.0/rank. The request body looks # like: 

# {"issueKeys":["ANERDS-102"],"rankBeforeKey":"ANERDS-94","rankAfterKey":"ANERDS-7","customFieldId":10050}
# The issueKeys are the items to rank (there can be several), the rankBeforeKey is the issue to rank the items before and the rankAfterKey is the issue to rank these items after. # Because there may be multuple Global Rank fields in your JIRA the customFieldId is used to specify which one is used for this ranking.

    # "customfield_10050": {
    #   "required": false,
    #   "schema": {
    #     "type": "array",
    #     "items": "string",
    #     "custom": "com.pyxis.greenhopper.jira:gh-global-rank",
    #     "customId": 10050
    #   },
    #   "name": "Global Rank",
    #   "operations": ["set"]
    # },
class RankIssue < LoggedInCommand
  def initialize
    super
    @issue = ARGV[1]
    @after = ARGV[2]
    @before = ARGV[3]
  end
  
  def description
    return "rank #{@issue} after #{@after} before #{@before}"
  end
  
  
  def run_logged_in
    ans = JiraHelpers.rank(@issue, @after, @before)
    return ans
  end
  
end

class RankSprint < LoggedInCommand
  def initialize
    super
    @sprintNumber = InputHelpers.sprint_name(ARGV[1])
  end
  
  def description
    return "rank #{@sprintNumber}"
  end
  
  
  def run_logged_in_old
    ans = JiraHelpers.rank(@issue, @after, @before)
    return ans
  end

  def run_logged_in
    sp_issues = retrieve_sprint_issues()
    bis_issues = retrieve_bis_issues(sp_issues)
    
    self.rank_issues(sp_issues, bis_issues)
    self.print_issues
    # Nothing to show
    return "#{sp_issues.length} issues"
  end
  
  def retrieve_sprint_issues()
    query = "project=SP AND fixVersion = #{@sprintNumber} ORDER BY \"Global Rank\" ASC" 
    sp_issues = JiraHelpers.search_full(query, @silent)
    init_sp_issue_dict(sp_issues)
    return sp_issues
  end
  
  def retrieve_bis_issues(sp_issues)
    implemented_issues = []
    sp_issues.each do | issue |
      implements_key = issue.implements.key unless issue.implements.nil?
      implemented_issues << issue.implements unless issue.implements.nil?
    end
    bis_issue_list = implemented_issues.collect{|issue| issue.key }.join(",")
    bis_query= "project = BIS AND key in (#{bis_issue_list}) ORDER BY \"Global Rank\" ASC"
    bis_issues = JiraHelpers.search_full(bis_query, @silent)
    return bis_issues
  end    
  
  def init_sp_issue_dict(sp_issues)
    @sp_issue_dict = {}
    sp_issues.each do | issue |
      key = issue.key
      @sp_issue_dict[key] = issue
    end
  end
  
  def rank_issues(sp_issues, bis_issues)
    not_in_bis = []
    bis_ranking = []
    seen_sp_issues = [].to_set
    bis_issues.each do | bis_issue |
      bis_issue.implemented_by.each do | sp |
        unless @sp_issue_dict[sp.key].nil?
          seen_sp_issues << sp.key
          bis_ranking << @sp_issue_dict[sp.key]
        end
      end
    end
    
    sp_issues.each do | sp_issue |
      not_in_bis << sp_issue unless seen_sp_issues.include?(sp_issue.key)
    end
    
    # not in bis comes first, in arbitrary order, then the remaining issues
    ranked_issues = not_in_bis + bis_ranking
    ranked_issues.each_cons(2) do | first, second |
      JiraHelpers.rank(second.key, first.key)
    end
    
  end
  
  def print_issues
    query = "project=SP AND fixVersion = #{@sprintNumber} ORDER BY \"Global Rank\" ASC" 
    full_issues = JiraHelpers.search_full(query, @silent)
    header = "%8s\t%12s\t%s" % ["Key", "Implements", "Summary"]
    puts header
    full_issues.each do | issue |
      key = issue.key
      implements_key = issue.implements.key unless issue.implements.nil?
      summary = issue.summary
      row = "%8s\t%12s\t%s" % [key, implements_key, summary]
      puts row
    end
    print " ", ("-" * 27), "\n"
  end  
  
end

#
# Lists the issues in the sprint
#
class ListSprint < LoggedInCommand
  def initialize
    super
    @sprintNumber = InputHelpers.sprint_name(ARGV[1])
  end
  
  def description
    return "sprint #{@sprintNumber}"
  end
  
  
  def run_logged_in
    query = "project=SP AND fixVersion = #{@sprintNumber} ORDER BY \"Global Rank\" ASC" 
    full_issues = JiraHelpers.search_full(query, @silent)
    self.print_issues_table(full_issues)
    # Nothing to show
    return "#{full_issues.length} issues"
  end
  
  def print_issues_table(full_issues)
    header = "%8s\t%12s\t%6s\t%12s\t%8s\t%s" % ["Key", "Implements", "Time", "Status", "Tester", "Summary"]
    puts header
    time_remaining = 0.0
    full_issues.each do | issue |
      key = issue.key
      implements_key = issue.implements.key unless issue.implements.nil?
      time = issue.time
      status = issue.status
      tester = issue.tester
      summary = issue.summary
      row = "%8s\t%12s\t%6s\t%12s\t%8s\t%s" % [key, implements_key, ptime(time), status, tester, summary]
      puts row
      
      # Tasks that are resolved can be considered to have 0 time remaining
      time_remaining = time_remaining + time unless (status == "Resolved" || status == "Closed")
    end
    print " ", ("-" * 27), "\n"
    puts "   Time Remaining : %.1fh" % (time_remaining / 3600.0)
  end
end


#
# List the issues slated for a sprint in a form that is helpful for planning
#
class PlanSprint < LoggedInCommand
  def initialize
    super
    @sprintNumber = InputHelpers.sprint_name(ARGV[1])
    @total = 0
    @skip_issues_in_other_sprint = false
  end
  
  def description
    return "plan #{@sprintNumber}"
  end
  
  
  def run_logged_in
    sp_query = "project=SP AND fixVersion = #{@sprintNumber} ORDER BY \"Global Rank\" ASC" 
    sp_issues = JiraHelpers.search_full(sp_query, @silent)
    init_sp_issue_dict(sp_issues)
    
    bis_query= "project = BIS AND status not in (Resolved, Closed) AND \"Next Sprint\" = YES ORDER BY \"Global Rank\" ASC"
    bis_issues = JiraHelpers.search_full(bis_query, @silent)
    enrich_sp_issue_dict(JiraHelpers.retrieve_implementors(bis_issues, @silent))
    
    ccs_query= "project = CCS AND status not in (Resolved, Closed) AND \"Next Sprint\" = YES ORDER BY \"Global Rank\" ASC"
    ccs_issues = JiraHelpers.search_full(ccs_query, @silent)
    enrich_sp_issue_dict(JiraHelpers.retrieve_implementors(ccs_issues, @silent))    
    
    swe_query= "project = SWE AND status not in (Resolved, Closed) AND \"Next Sprint\" = YES ORDER BY \"Global Rank\" ASC"
    swe_issues = JiraHelpers.search_full(swe_query, @silent)
    enrich_sp_issue_dict(JiraHelpers.retrieve_implementors(swe_issues, @silent))
    
    ysc_query= "project = YSC AND status not in (Resolved, Closed) AND \"Next Sprint\" = YES ORDER BY \"Global Rank\" ASC"
    ysc_issues = JiraHelpers.search_full(ysc_query, @silent)
    enrich_sp_issue_dict(JiraHelpers.retrieve_implementors(ysc_issues, @silent))    
    
    print_issues_table("BIS", bis_issues)
    print_issues_table("CCS", ccs_issues)    
    print_issues_table("SWE", swe_issues)
    print_issues_table("YSC", ysc_issues)    
    print_unseen_sp_issues_table(sp_issues)
    
    puts ("=" * 12)
    puts "Total %8.1fh" % [@total / 3600.0]
    puts ("-" * 12)

    # Nothing to show
    issue_count = bis_issues.length + ccs_issues.length + swe_issues.length
    return "#{issue_count} issues"
  end
  
  def init_sp_issue_dict(sp_issues)
    @sp_issue_dict = {}
    sp_issues.each do | issue |
      key = issue.key
      @sp_issue_dict[key] = issue
    end
    @seen_sp_issues = [].to_set
  end
  
  #
  # Take those issues that are not yet resolved / closed and add them to the sp issues dict
  #
  def enrich_sp_issue_dict(implementors)
    implementors.each do | issue |
      sp = issue.key
      next if @sp_issue_dict[sp]
      
      status = issue.status
      @sp_issue_dict[sp] = issue unless issue.resolved_or_closed?
    end 
  end
  
  def print_unseen_sp_issues_table(full_issues)
    puts ("=" * 12)
    puts "SP Missed"
    puts ("-" * 12)
    header = "%8s\t%12s\t%12s\t%6s\t%s" % ["Subtotal", "Key", "SP", "Time", "Summary"]
    puts header
    subtotal = 0.0
    full_issues.each do | issue |
      sp = issue.key
      next if @seen_sp_issues.include?(sp)
      
      key = "----"
      key = issue.implements.key unless issue.implements.nil?
      time = issue.time
      summary = issue.summary
      # Tasks that are resolved can be considered to have 0 time remaining
      status = issue.status
      subtotal = subtotal + time unless status == "Resolved"
      row = "%8.1fh\t%12s\t%12s\t%6s\t%s" % [subtotal / 3600.0, key, sp, ptime(time), summary]
      puts row
    end
    @total = @total + subtotal
  end
  
  def print_issues_table(title, full_issues)
    return if full_issues.length < 1
    
    puts ("=" * 12)
    puts title
    puts ("-" * 12)
    header = "%8s\t%12s\t%12s\t%6s\t%s" % ["Subtotal", "Key", "SP", "Time", "Summary"]
    puts header
    subtotal = 0.0
    full_issues.each do | issue |
      key = issue.key
      summary = issue.summary
      parent = issue.fields["parent"]
      parent = parent["key"] unless parent.nil?
      summary = "#{parent} / #{summary}" unless parent.nil?
            
      implementedby = []
      issue.implemented_by.each do | sp_issue |
        sp = sp_issue.key
        # We are only interested in links to issues in the specified sprint
        implementedby << sp if @sp_issue_dict[sp]
      end
      
      if implementedby.length < 1
        row = "%8s\t%12s\t%12s\t%6s\t%s" % ["----", key, "----", "", summary]
        puts row
        next
      end
      
      implementedby.each_with_index do | sp, index |
        # print one row for each implemented by
        spissue = @sp_issue_dict[sp]
        next if spissue.nil?
        next if @seen_sp_issues.include?(sp)
        fix_version = spissue.fix_version
        issue_in_different_sprint = fix_version != @sprintNumber
        next if @skip_issues_in_other_sprint && issue_in_different_sprint     
        
        spfields = spissue.fields
        time = spissue.time

        # Tasks that are resolved can be considered to have 0 time remaining

        status = spissue.status       
        subtotal = subtotal + time unless (status == "Resolved" || status == "Closed" || issue_in_different_sprint)
        if index < 1 
          issue_summary = spissue.summary
          issue_summary =  "[#{fix_version}] #{issue_summary}" if issue_in_different_sprint
          row = "%8.1fh\t%12s\t%12s\t%6s\t%s" % [subtotal / 3600.0, key, sp, ptime(time), issue_summary]
        else
          issue_summary = spissue.summary
          issue_summary =  "[#{fix_version}] #{issue_summary}" if issue_in_different_sprint
          row = "%8.1fh\t%12s\t%12s\t%6s\t%s" % [subtotal / 3600.0, "\"", sp, ptime(time), issue_summary]
        end
        puts row
        @seen_sp_issues.add(sp)
      end
    end
    @total = @total + subtotal
  end
end

#
# Create sprint issues for the issues in the sprint
#
class CreateSprint < LoggedInCommand
  def initialize
     super
     @sprintNumber = ARGV[1]
     @sprintNumber = "S" if @sprintNumber.nil?
     @sprintNumber = "S" + @sprintNumber unless @sprintNumber.match("^[S|s].*")
     @parent_issue = ARGV[2]
   end

  def description
    return "create #{@sprintNumber}"
  end


  def run_logged_in
    header = "%12s\t%12s\t%s" % ["Key", "SP", "Summary"]
    puts header
        
    # if no issue is specified, create all issues that relate to bis
    return create_bis_issues if @parent_issue.nil?
    
    # create the issue explicitly requested
    return create_explicit_issue
  end
  
  def create_explicit_issue
    issue = JiraHelpers.issue(@parent_issue)
    create_issues(@parent_issue, [issue])
    return "1 issue"
  end
   
  def create_bis_issues
    sp_query = "project=SP AND fixVersion = #{@sprintNumber} ORDER BY \"Global Rank\" ASC" 
    sp_issues = JiraHelpers.search_full(sp_query, @silent)
    init_sp_issue_dict(sp_issues)

    bis_query= "project = BIS AND status not in (Resolved, Closed) AND \"Next Sprint\" = YES ORDER BY \"Global Rank\" ASC"
    bis_issues = JiraHelpers.search_full(bis_query, @silent)
    enrich_sp_issue_dict(JiraHelpers.retrieve_implementors(bis_issues, @silent))

    ccs_query= "project = CCS AND status not in (Resolved, Closed) AND \"Next Sprint\" = YES ORDER BY \"Global Rank\" ASC"
    ccs_issues = JiraHelpers.search_full(ccs_query, @silent)
    enrich_sp_issue_dict(JiraHelpers.retrieve_implementors(ccs_issues, @silent))    

    swe_query= "project = SWE AND status not in (Resolved, Closed) AND \"Next Sprint\" = YES ORDER BY \"Global Rank\" ASC"
    swe_issues = JiraHelpers.search_full(swe_query, @silent)
    enrich_sp_issue_dict(JiraHelpers.retrieve_implementors(swe_issues, @silent))

    create_necessary_issues("BIS", bis_issues)
    #     print_issues_table("CCS", ccs_issues)
    #     print_issues_table("SWE", swe_issues)

    # Nothing to show
    issue_count = bis_issues.length + ccs_issues.length + swe_issues.length
    return "#{issue_count} issues"
  end

  def init_sp_issue_dict(sp_issues)
     @sp_issue_dict = {}
     sp_issues.each do | issue |
       key = issue.key
       @sp_issue_dict[key] = issue
     end
     @seen_sp_issues = [].to_set
  end

  #
  # Take those issues that are not yet resolved / closed and add them to the sp issues dict
  #
  def enrich_sp_issue_dict(implementors)
     implementors.each do | issue |
       sp = issue.key
       next if @sp_issue_dict[sp]

       status = issue.status
       @sp_issue_dict[sp] = issue unless (status == "Resolved" || status == "Closed")
     end 
  end  

  def create_necessary_issues(title, full_issues)
    issues_to_create = []
    full_issues.each do | issue |
      is_umbrella = !issue.fields["sub-tasks"].nil?
      next if is_umbrella
      implementedby = []
      issue.implemented_by.each do | sp_issue |
        sp = sp_issue.key
        # We are only interested in links to issues in the specified sprint
        implementedby << sp if @sp_issue_dict[sp]
      end

      issues_to_create << issue if implementedby.length < 1
    end
    create_issues(title, issues_to_create)    
  end
  
  def create_issues(title, issues_to_create)
    puts ("=" * 12)
    puts title
    puts ("-" * 12)
    issues_to_create.each do  | issue |
      summary = "#{issue.key} : #{issue.summary}"
      desc = "See #{issue.key}."
      sp = JiraHelpers.create_sp_issue(summary, desc, @sprintNumber)
      sp_key = sp["key"]
      JiraHelpers.link_sp_to_bis(sp_key, issue.key)
      row = "%12s\t%12s\t%s" % [issue.key, sp_key, summary]
      puts row
    end
  end
end

#
# List the issues slated from customer projects
#
class CustIssues < LoggedInCommand
  def initialize
    super
  end
  
  def description
    return "cust"
  end
  
  
  def run_logged_in
    obp_query = "project=OBP AND status not in (Resolved, Closed) ORDER BY \"Global Rank\" ASC"
    obp_issues = JiraHelpers.search_full(obp_query, @silent)
    
    sob_query = "project=SOB AND status not in (Resolved, Closed) ORDER BY \"Global Rank\" ASC"
    sob_issues = JiraHelpers.search_full(sob_query, @silent)
    
    all_issues = [obp_issues, sob_issues].flatten
    implementors = JiraHelpers.retrieve_implementors(all_issues, @silent)
    init_implementors_dict(implementors)
    
    print_issues_table("OBP", obp_issues)
    print_issues_table("SOB", sob_issues)
    
    # Nothing to show
    return "#{all_issues.length} issues"
  end
  
  def init_implementors_dict(implementors)
    @implementors_dict = {}
    implementors.each do | issue |
      key = issue.key
      @implementors_dict[key] = issue
    end
  end
  
  def print_issues_table(title, full_issues)
    puts ("=" * 12)
    puts title
    puts ("-" * 12)
    header = "%12s\t%12s\t%s" % ["Key", "BIS", "Summary"]
    puts header
    full_issues.each do | issue |
      key = issue.key
      summary = issue.summary
            
      implementedby = issue.implemented_by
      
      if implementedby.length < 1
        row = "%12s\t%12s\t%s" % [key, "----", summary]
        puts row
        next
      end
      
      implementedby.each_with_index do | implementor, index |
        # print one row for each implemented by
        implementorissue = @implementors_dict[implementor]
        next if implementorissue.nil?
        implementorfields = implementorissue.fields
        time = 0        
        time = implementorfields["timetracking"]["value"]["timeestimate"] if implementorfields["timetracking"]["value"] != nil
        if index < 1 
          row = "%12s\t%12s\t%s" % [key, implementor, summary]
        else
          row = "%12s\t%12s\t%s" % ["\"", implementor, "\""]
        end
        puts row
      
        # Tasks that are resolved can be considered to have 0 time remaining
        status = implementorfields["status"]["value"]["name"]
      end
    end
  end  
end

#
# Starts the sprint by marking the issues as active and setting the next sprint flag to false
#
class StartSprint < LoggedInCommand
  def initialize
    super
    @sprintNumber = InputHelpers.sprint_name(ARGV[1])
  end
  
  def description
    return "start #{@sprintNumber}"
  end
  
  
  def run_logged_in
    query = "project=SP AND fixVersion = #{@sprintNumber} ORDER BY \"Global Rank\" ASC" 
    full_issues = JiraHelpers.search_full(query, @silent)
    self.set_active(full_issues)
    # Nothing to show
    return "#{full_issues.length} issues"
  end
  
  def set_active(full_issues)
    header = "Processing...\n"
    puts header
    processed = Set.new
    full_issues.each do | issue |
      next if issue.implements.nil?
      implements_key = issue.implements.key

      next if processed.include? implements_key
      processed << implements_key
      
      print "\t#{implements_key}"
      
      issue = JiraHelpers.issue(implements_key)
      
      if issue.next_sprint
        JiraHelpers.remove_next_sprint(implements_key)
      end
      print " Next Sprint -> nil"      
      
      start = issue.transitions.detect { | trans | "Start Sprint" == trans["name"] }
      unless start
        print " \tActive in sprint\n"
        # already started
        next
      end
      
      JiraHelpers.transition(implements_key, start["id"])
      print " \tActive in sprint\n"
    end
  end
end

#
# Finishes the sprint by marking the issues as resolved if there are no open issues associated with it, and setting the next sprint flag to true if there
# are still open issues
#
class FinishSprint < LoggedInCommand
  def initialize
    super
    @sprintNumber = InputHelpers.sprint_name(ARGV[1])
    @execute = ARGV[2] == "exec"
  end
  
  def description
    exec_status = "print"
    exec_status = "exec" if @execute
    return "finish #{@sprintNumber} #{exec_status}"
  end
  
  
  def run_logged_in
    query = "project=SP AND fixVersion = #{@sprintNumber} ORDER BY \"Global Rank\" ASC" 
    full_issues = JiraHelpers.search_full(query, @silent)
    if @execute
      self.resolve_or_move_to_next_sprint(full_issues)
    else
      self.print_parent_status(full_issues)
    end
    # Nothing to show
    return "#{full_issues.length} issues"
  end
  
  def print_parent_status(full_issues)
    header = "Status...\n"
    puts header    
    processed = Set.new
    full_issues.each do | issue |
      next if issue.implements.nil?
      implements_key = issue.implements.key

      next if processed.include? implements_key
      processed << implements_key
      
      key_to_print = "%12s" % [implements_key]
      print "#{key_to_print}"
      
      issue = JiraHelpers.issue(implements_key)
      
      can_resolve = issue.transitions.detect { | trans | "Resolve Issue" == trans["name"] }
      if can_resolve
        status_string = "%9s %8s" % ["Active", ""]
      else
        status_string = "%9s %8s" % ["Resolved", "#{issue.fix_version}"]
      end
            
      print status_string, " "

      open_issue = issue.implemented_by.detect { | implementor | !implementor.resolved_or_closed? }
      if open_issue
        open_string = "%9s" % open_issue.key
      else
        if issue.key.match(/^CCS/)
          open_string = "%9s" % "Customer"          
        else
          open_string = "%9s" % "Finished"
        end
      end
      
      print open_string, " "
      
      print issue.summary
      print "\n"
    end
    print "finish #{@sprintNumber} exec to change status\n"
  end
  
  def resolve_or_move_to_next_sprint(full_issues)
    header = "Processing...\n"
    puts header
    processed = Set.new
    full_issues.each do | issue |
      next if issue.implements.nil?
      implements_key = issue.implements.key

      next if processed.include? implements_key
      processed << implements_key
      
      print "\t#{implements_key}"
      
      issue = JiraHelpers.issue(implements_key)
      
      open_issue = issue.implemented_by.detect { | implementor | !implementor.resolved_or_closed? }
      if open_issue
        self.move_to_next_sprint(issue)
      else
        self.resolve(issue)
      end
      
      print "\n"
    end
  end
    
  def resolve(issue)
    
    if issue.key.match(/^CCS/)
      print " Customer"
      return
    end
    
    resolve = issue.transitions.detect { | trans | "Resolve Issue" == trans["name"] }
    if resolve
      JiraHelpers.transition(issue.key, resolve["id"])
      print " Resolved"          
    else
      print " Already Resolved"      
    end
    
    JiraHelpers.add_fix_version(issue, @sprintNumber)
    print ", Fix version #{@sprintNumber}"
    
  end
  
  def move_to_next_sprint(issue)
    if issue.next_sprint
      print " Next Sprint"
    else
      JiraHelpers.set_next_sprint(issue.key)
      print " Moved to Next Sprint"
    end
  end    
end

#
# Move an issue into a particular sprint
#
class MoveIssue < LoggedInCommand
  def initialize
     super
     @sprintNumber = ARGV[1]
     @sprintNumber = "S" if @sprintNumber.nil?
     @sprintNumber = "S" + @sprintNumber unless @sprintNumber.match("^[S|s].*")
     @issue = ARGV[2]
   end

  def description
    return "move #{@sprintNumber} #{@issue}"
  end


  def run_logged_in
    return move_issue
  end
  
  def move_issue
    issue = JiraHelpers.issue(@issue)
    move_issues([issue])
    return "1 issue"
  end
  
  def move_issues(issues_to_move)
    issues_to_move.each do  | issue |
      JiraHelpers.set_fix_version(issue.key, @sprintNumber)
    end
  end
    
end

#
# Move an issue into a particular sprint
#
class MoveSprint < LoggedInCommand
  def initialize
     super
     @sprintNumber = ARGV[1]
     @sprintNumber = "S" if @sprintNumber.nil?
     @sprintNumber = "S" + @sprintNumber unless @sprintNumber.match("^[S|s].*")
     @issue = ARGV[2]
   end

  def description
    return "move #{@sprintNumber} #{@issue}"
  end


  def run_logged_in
    return search_and_move_issues
  end
  
  def search_and_move_issues
    sp_query = "project=SP AND fixVersion = #{@sprintNumber} ORDER BY \"Global Rank\" ASC" 
    sp_issues = JiraHelpers.search_full(sp_query, @silent)
    init_sp_issue_dict(sp_issues)

    bis_query= "project = BIS AND status not in (Resolved, Closed) AND \"Next Sprint\" = YES ORDER BY \"Global Rank\" ASC"
    bis_issues = JiraHelpers.search_full(bis_query, @silent)

    ccs_query= "project = CCS AND status not in (Resolved, Closed) AND \"Next Sprint\" = YES ORDER BY \"Global Rank\" ASC"
    ccs_issues = JiraHelpers.search_full(ccs_query, @silent)

    swe_query= "project = SWE AND status not in (Resolved, Closed) AND \"Next Sprint\" = YES ORDER BY \"Global Rank\" ASC"
    swe_issues = JiraHelpers.search_full(swe_query, @silent)

    move_necessary_issues("BIS", bis_issues)
    #     print_issues_table("CCS", ccs_issues)
    #     print_issues_table("SWE", swe_issues)

    # Nothing to show
    issue_count = bis_issues.length + ccs_issues.length + swe_issues.length
    return "#{issue_count} issues"
  end  
  
  def init_sp_issue_dict(sp_issues)
     @sp_issue_dict = {}
     sp_issues.each do | issue |
       key = issue.key
       @sp_issue_dict[key] = issue
     end
     @seen_sp_issues = [].to_set
  end

  #
  # Take those issues that are not yet resolved / closed and add them to the sp issues dict
  #
  def enrich_sp_issue_dict(implementors)
     implementors.each do | issue |
       sp = issue.key
       next if @sp_issue_dict[sp]

       status = issue.status
       @sp_issue_dict[sp] = issue unless (status == "Resolved" || status == "Closed")
     end 
  end  

  def move_necessary_issues(title, full_issues)
    issues_to_move = []
    full_issues.each do | issue |
      is_umbrella = !issue.fields["sub-tasks"].nil?
      next if is_umbrella
      implementedby = []
      issue.implemented_by.each do | sp_issue |
        sp = sp_issue.key
        # Skip if the issue is already in this sprint
        next if @sp_issue_dict[sp]        
        issues_to_move << sp_issue unless sp_issue.resolved_or_closed?
      end

    end
    move_issues(title, issues_to_move)    
  end
  
  def move_issues(title, issues_to_move)
    puts ("=" * 12)
    puts title
    puts ("-" * 12)
    
    issues_to_move.each do  | issue |
      JiraHelpers.set_fix_version(issue.key, @sprintNumber)
      row = "%12s\t%s" % [issue.key, @sprintNumber]
      puts row
    end
  end
end

#
#  Add a fix version to an issue
#
class FixVersionAdd < LoggedInCommand
  def initialize
    super
    @fix_version = ARGV[1]
    @issue_keys = ARGV[2]
    @issue_keys = @issue_keys.split(",").collect { | each | each.strip() } if @issue_keys
    @issue_keys = [] unless @issue_keys    
  end
  
  def description
    return "fix-add #{@fix_version} #{@issue_keys.inspect}"
  end
  
  
  def run_logged_in
    return "fix-add [fix version] [issue key]" unless @fix_version        
    return "fix-add [fix version] [issue key]" if @issue_keys.empty?
    @issue_keys.each do | issue_key |
      issue = JiraHelpers.issue(issue_key)
      unless issue.key
        puts "Issue #{issue_key} unknown"
        next
      end
      ans = JiraHelpers.add_fix_version(issue, @fix_version)
      issue = JiraHelpers.issue(issue_key)
      puts "#{issue.key} versions: #{issue.fix_versions}"
    end
    return "Updated #{@issue_keys.size} issues"
  end
end

#
# Lists the issues in the sprint that need to be ported to the release branch
#
class ListPort1304 < LoggedInCommand
  def initialize
    super
    @sprintNumber = InputHelpers.sprint_name(ARGV[1])
  end
  
  def description
    return "port1304 #{@sprintNumber}"
  end
  
  
  def run_logged_in
    sp_query = "project=SP AND fixVersion = #{@sprintNumber} ORDER BY \"Global Rank\" ASC" 
    sp_issues = JiraHelpers.search_full(sp_query, @silent)
    init_sp_issue_dict(sp_issues)
    
    bis_query= "project=BIS AND fixVersion = #{@sprintNumber} AND labels in (\"12.xx_REL\", \"13.04.X\") ORDER BY \"Global Rank\" ASC"
    bis_issues = JiraHelpers.search_full(bis_query, @silent)
    enrich_sp_issue_dict(JiraHelpers.retrieve_implementors(bis_issues, @silent))
    
    self.print_issues_table("BIS", bis_issues)
    self.print_unseen_sp_issues_table(sp_issues)
   return "Invoke to get commits: port1304 #{@sprintNumber} commits"       
  end
  
  
  def init_sp_issue_dict(sp_issues)
    @sp_issue_dict = {}
    sp_issues.each do | issue |
      key = issue.key
      @sp_issue_dict[key] = issue
    end
    @seen_sp_issues = [].to_set
  end
  
  #
  # Take those issues that are not yet resolved / closed and add them to the sp issues dict
  #
  def enrich_sp_issue_dict(implementors)
    implementors.each do | issue |
      sp = issue.key
      next if @sp_issue_dict[sp]
      
      status = issue.status
      @sp_issue_dict[sp] = issue unless issue.resolved_or_closed?
    end 
  end  
  
  def print_issues_table(title, full_issues)
    return if full_issues.length < 1
    
    puts ("=" * 12)
    puts title
    puts ("-" * 12)
    header = "%12s\t%12s\t%6s\t%s" % ["Key", "SP", "Port?", "Summary"]
    puts header
    full_issues.each do | issue |
      key = issue.key
      summary = issue.summary
      parent = issue.fields["parent"]
      parent = parent["key"] unless parent.nil?
      summary = "#{parent} / #{summary}" unless parent.nil?
            
      implementedby = []
      issue.implemented_by.each do | sp_issue |
        sp = sp_issue.key
        # We are only interested in links to issues in the specified sprint
        implementedby << sp if @sp_issue_dict[sp]
      end
      
      if implementedby.length < 1
        row = "%12s\t%12s\t%6s\t%s" % [key, "----", "NO", summary]
        puts row
        next
      end
      
      implementedby.each_with_index do | sp, index |
        # print one row for each implemented by
        spissue = @sp_issue_dict[sp]
        next if spissue.nil?
        next if @seen_sp_issues.include?(sp)
        
        spfields = spissue.fields
        time = spissue.time

        # Tasks that are resolved can be considered to have 0 time remaining
        fix_version = spissue.fix_version
        issue_in_different_sprint = fix_version != @sprintNumber
        status = spissue.status
        if index < 1 
          issue_summary = summary
          issue_summary =  "[#{fix_version}] #{issue_summary}" if issue_in_different_sprint
          row = "%12s\t%12s\t%6s\t%s" % [key, sp, "YES", issue_summary]
        else
          issue_summary = "\""
          issue_summary =  "[#{fix_version}] #{issue_summary}" if issue_in_different_sprint
          row = "%12s\t%12s\t%6s\t%s" % ["\"", sp, "YES", issue_summary]
        end
        puts row
        @seen_sp_issues.add(sp)
      end
    end
  end
  
  def print_unseen_sp_issues_table(full_issues)
    puts ("=" * 12)
    puts "Not Ported"
    puts ("-" * 12)
    header = "%12s\t%12s\t%6s\t%s" % ["Key", "SP", "Port?", "Summary"]
    puts header
    full_issues.each do | issue |
      sp = issue.key
      next if @seen_sp_issues.include?(sp)
      
      key = "----"
      key = issue.implements.key unless issue.implements.nil?
      time = issue.time
      summary = issue.summary
      # Tasks that are resolved can be considered to have 0 time remaining
      status = issue.status
      row = "%12s\t%12s\t%6s\t%s" % [key, sp, "NO", summary]
      puts row
    end
  end  

end

#
# Lists the commits in the sprint that need to be ported to the stage branch
#
class ListPortCommits1304 < LoggedInCommand
  def initialize
    super
    @sprintNumber = InputHelpers.sprint_name(ARGV[1])
  end
  
  def description
    return "port1304 #{@sprintNumber}"
  end
  
  
  def run_logged_in
    query = "project=BIS AND fixVersion = #{@sprintNumber} AND labels in (\"12.xx_REL\", \"13.04.X\") ORDER BY \"Global Rank\" ASC" 
    full_issues = JiraHelpers.search_full(query, @silent)
    self.print_issues_table(full_issues)
    # Nothing to show
    return "#{full_issues.length} issues"
  end
  
  def print_issues_table(full_issues)
    header = "%8s\t%8s\t%8s\t%12s\t%s" % ["BIS", "SP", "Sprint", "Status", "Commits"]
    puts header
    time_remaining = 0.0
    full_issues.each do | issue |
      key = issue.key
      issue.implemented_by.each do | sp_minimal |
        sp = JiraHelpers.issue(sp_minimal.key)
        status = sp.status
        commits = self.list_commits(sp)
        row = "%8s\t%8s\t%8s\t%12s\t%s" % [key, sp.key, sp.fix_version, status, commits]
        puts row
      end
      
    end
    print " ", ("-" * 27), "\n"
  end
  
  def list_commits(issue)
    key = issue.key
    # Restrict outselves to the svn reveion number lines and then print the revision number prefixed with 'r'
    commits = GitHelpers.list_commits(key)
    commits = commits.split(/\n/).join(',')
    return commits
  end
end

#
# Abstract command that joins together SP issues with issues from other projects
#
class JoinedCommand < LoggedInCommand
  def initialize
    super
    @sprintNumbers = InputHelpers.sprint_names(ARGV[1])

    # This is state available to subclasses
    @joined_issues = []     # A collection of tuples where the first elt is the original issue 
                            # and the second element a list with implementors (sorted by sprint and key)
                            # The list is sorted accourding to implementor key
    @standalone_issues = []  # A collction of issues that are not connected to anything
  end
  
  # def description
  #   return "benefit #{@sprintNumber}"
  # end
  
  
  def run_logged_in
    sprints = @sprintNumbers.join(",")
    query = "project=SP AND fixVersion in (#{sprints}) ORDER BY \"Global Rank\" ASC"
    @sp_issues = JiraHelpers.search_full(query, @silent, 1000)
    @implements = JiraHelpers.retrieve_full_implements(@sp_issues, @silent, 1000)
    self.construct_joined_issues()

    # Nothing to show
    return "#{@sp_issues.length} issues"
  end
  
  def construct_joined_issues
    @implements.sort { | a, b| a.key <=> b.key }

    # Need a dictionary containing the full implements issue since this information is not included in the SP issues
    implements_dict = {}
    joined_issues_dict = {}
    @implements.each do | issue |
      implements_dict[issue.key] = issue
      joined_issues_dict[issue.key] = []
    end

    @sp_issues.each do | issue |
      key = issue.key
      implements = issue.implements
      implements_key = nil
      implements_key = implements.key if implements
      if implements_key and joined_issues_dict[implements_key]
        joined_issues_dict[implements_key].push(issue)
      else
        @standalone_issues.push(issue)
      end
    end

    @implements.each do | issue |
      implemented = joined_issues_dict[issue.key]
      implemented.sort do | a, b| 
        fix_version_order = a.fix_version <=> b.fix_version
        if fix_version_order != 0
          fix_version_order
        else
          a.key <=> b.key
        end
      end

      @joined_issues.push([issue, implemented])
    end
  end
  
  def print_beneficiaries_report()
    header = "Beneficiaries Report...\n"
    header = "%8s\t%8s\t%s" % ["BIS", "SP", "Beneficiaries"]
    puts header
    @full_issues.each do | issue |
      key = issue.key
      implements = issue.implements
      implements_key = nil
      implements_key = implements.key if implements
      if implements_key and @implements_dict[implements_key]
        beneficiaries = @implements_dict[implements_key].beneficiaries
      else
        beneficiaries = []
      end
      row = "%8s\t%8s\t%s" % [implements_key, key, JSON.generate(beneficiaries)]
      puts row      
    end
  end
end

#
# Puts together a report of which clients we worked for
#
class BeneficiariesReport < JoinedCommand
  
  def description
    return "benefit #{@sprintNumbers}"
  end
  
  
  def run_logged_in
    super
    self.print_beneficiaries_report()

    # Nothing to show
    return "#{@joined_issues.length + @standalone_issues.length} issues"
  end
  
  def print_beneficiaries_report()
    header = "Beneficiaries Report...\n"
    columns = "%8s\t%8s\t%8s\t%8s\t%8s\t%20s\t%s"
    header =  columns % ["BIS", "SP", "Sprint", "Time", "B Count", "Beneficiaries", "Summary"]
    puts header
    @joined_issues.each do | pair |
      bis = pair[0]
      sps = pair[1]
      sps.each do | sp | 
        row = columns % [bis.key, sp.key, sp.fix_version, sp.time_spent, bis.beneficiaries.length, JSON.generate(bis.beneficiaries), sp.summary]
        puts row 
      end
    end
    @standalone_issues.each do | sp |
      row = columns % ["", sp.key, sp.fix_version, sp.time_spent, 1, "", sp.summary]
      puts row     
    end    
  end
end

#
# Puts together a report of which clients we worked for
#
class BeneficiariesReportOld < LoggedInCommand
  def initialize
    super
    @sprintNumber = InputHelpers.sprint_name(ARGV[1])
  end
  
  def description
    return "benefit #{@sprintNumber}"
  end
  
  
  def run_logged_in
    query = "project=SP AND fixVersion = #{@sprintNumber} ORDER BY \"Global Rank\" ASC" 
    @full_issues = JiraHelpers.search_full(query, @silent)
    @implements = JiraHelpers.retrieve_full_implements(@full_issues, @silent)
    self.construct_implements_dict()
    self.print_beneficiaries_report()

    # Nothing to show
    return "#{@full_issues.length} issues"
  end
  
  def construct_implements_dict
    # Need a dictionary containing the full implements issue since this information is not included in the SP issues
    @implements_dict = {}
    @implements.each do | issue |
      @implements_dict[issue.key] = issue
    end
  end
  
  def print_beneficiaries_report()
    header = "Beneficiaries Report...\n"
    header = "%8s\t%8s\t%s" % ["BIS", "SP", "Beneficiaries"]
    puts header
    @full_issues.each do | issue |
      key = issue.key
      implements = issue.implements
      implements_key = nil
      implements_key = implements.key if implements
      if implements_key and @implements_dict[implements_key]
        beneficiaries = @implements_dict[implements_key].beneficiaries
      else
        beneficiaries = []
      end
      row = "%8s\t%8s\t%s" % [implements_key, key, JSON.generate(beneficiaries)]
      puts row      
    end
  end
end

#
# Puts together a report of how much time we worked for each client
#
class TimeReport < LoggedInCommand
  def initialize
    super
    @sprintNumber = InputHelpers.sprint_name(ARGV[1])
  end
  
  def description
    return "report #{@sprintNumber}"
  end
  
  
  def run_logged_in
    query = "project=SP AND fixVersion = #{@sprintNumber} ORDER BY \"Global Rank\" ASC" 
    @full_issues = JiraHelpers.search_full(query, @silent)
    @implements = JiraHelpers.retrieve_full_implements(@full_issues, @silent)
    @users = Set.new
    self.construct_implements_dict()
    self.gather_time_data()
    self.print_time_report()

    # Nothing to show
    return "#{@full_issues.length} issues"
  end
  
  def construct_implements_dict
    # Need a dictionary containing the full implements issue since this information is not included in the SP issues
    @implements_dict = {}
    @implements.each do | issue |
      @implements_dict[issue.key] = issue
    end
  end

  def accumulate_beneficiary_user_time(issue, beneficiary, factor)
    @beneficiary_user_time[beneficiary] = {} unless @beneficiary_user_time[beneficiary]
    entry = @beneficiary_user_time[beneficiary]
    
    issue.worklogs.each do | worklog_entry |
      user = worklog_entry["author"]["name"]
      entry[user] = 0 unless entry[user]
      entry[user] = entry[user] + (worklog_entry["timeSpentSeconds"] * factor)   
      @users << user
    end
  end  
  
  def accumulate_user_time(issue)
    implements = issue.implements
    implements_key = nil
    implements_key = implements.key if implements
    if implements_key and @implements_dict[implements_key]
      beneficiaries = @implements_dict[implements_key].beneficiaries
    else
      beneficiaries = ["Infrastructure"]
    end

    factor = 1.0 / beneficiaries.size
    beneficiaries.each do | beneficiary |
      self.accumulate_beneficiary_user_time(issue, beneficiary, factor)
    end
  end
  
  
  def gather_time_data()
    # Summarize work per user on each issue
    @beneficiary_user_time = {}
    @full_issues.each do | issue |
      accumulate_user_time(issue)
    end
  
  end
  
  def print_time_report()
    header = "%9s\t" % ['User']
    beneficiaries = @beneficiary_user_time.keys.sort
    beneficiaries.each { | key | header = header + ("%9s\t" % [key]) }
    header = header + "Total"
    puts header    

    @users.sort.each do | user |
      print "%9s\t" % [user]
      total = 0
      beneficiaries.each do | beneficiary |
        all_time = @beneficiary_user_time[beneficiary]
        user_time = all_time[user]
        user_time = 0 unless user_time
        total = total + user_time
        print "%9s\t" % [self.ptime(user_time)]
      end
      print "#{self.ptime(total)}\n"
    end

    # Summary row
    print "%9s\t" % ["Total"]
    total = 0
    beneficiaries.each do | beneficiary |
      all_time = @beneficiary_user_time[beneficiary]
      issue_total = 0 if all_time.values.empty?
      issue_total = all_time.values.reduce(:+) unless all_time.values.empty?
      total = total + issue_total
      print "%9s\t" % [self.ptime(issue_total)]
    end
    print "#{self.ptime(total)}\n"    
  end
end

#
# Puts together a report of how much time we worked for each client over a range of sprints.
# This version ignores issues with beneficiary
#
class TimeReportRange < LoggedInCommand
  def initialize
    super
    @sprintNumber = InputHelpers.sprint_name(ARGV[1])
    @sprintNumber2 = InputHelpers.sprint_name(ARGV[2])    
  end
  
  def description
    return "report #{@sprintNumber}"
  end
  
  
  def run_logged_in
    query = "project=SP AND fixVersion = #{@sprintNumber} ORDER BY \"Global Rank\" ASC" 
    @full_issues = JiraHelpers.search_full(query, @silent)
    @implements = JiraHelpers.retrieve_full_implements(@full_issues, @silent)
    @users = Set.new
    self.construct_implements_dict()
    self.gather_time_data()
    self.print_time_report()

    # Nothing to show
    return "#{@full_issues.length} issues"
  end
  
  def construct_implements_dict
    # Need a dictionary containing the full implements issue since this information is not included in the SP issues
    @implements_dict = {}
    @implements.each do | issue |
      @implements_dict[issue.key] = issue
    end
  end

  def accumulate_beneficiary_user_time(issue, beneficiary, factor)
    @beneficiary_user_time[beneficiary] = {} unless @beneficiary_user_time[beneficiary]
    entry = @beneficiary_user_time[beneficiary]
    
    issue.worklogs.each do | worklog_entry |
      user = worklog_entry["author"]["name"]
      entry[user] = 0 unless entry[user]
      entry[user] = entry[user] + (worklog_entry["timeSpentSeconds"] * factor)   
      @users << user
    end
  end  
  
  def accumulate_user_time(issue, include_empty)
    implements = issue.implements
    implements_key = nil
    implements_key = implements.key if implements
    if implements_key and @implements_dict[implements_key]
      beneficiaries = @implements_dict[implements_key].beneficiaries
    else
      return if !include_empty
      beneficiaries = ["Infrastructure"]
    end

    factor = 1.0 / beneficiaries.size
    beneficiaries.each do | beneficiary |
      self.accumulate_beneficiary_user_time(issue, beneficiary, factor)
    end
  end
  
  
  def gather_time_data()
    # Summarize work per user on each issue
    @beneficiary_user_time = {}
    @full_issues.each do | issue |
      accumulate_user_time(issue, false)
    end
  
  end
  
  def print_time_report()
    header = "%9s\t" % ['User']
    beneficiaries = @beneficiary_user_time.keys.sort
    beneficiaries.each { | key | header = header + ("%9s\t" % [key]) }
    header = header + "Total"
    puts header    

    # Summary row
    print "%9s\t" % ["Total"]
    total = 0
    beneficiaries.each do | beneficiary |
      all_time = @beneficiary_user_time[beneficiary]
      issue_total = 0 if all_time.values.empty?
      issue_total = all_time.values.reduce(:+) unless all_time.values.empty?
      total = total + issue_total
      print "%9s\t" % [self.ptime(issue_total)]
    end
    print "#{self.ptime(total)}\n"    
  end
end

#
# Set up the sprint boilerplate. Ensure that the fixVersion exists in all the projects and that the standard
# tasks are defined.
#
class SetupSprint < LoggedInCommand
  def initialize
    super
    @sprintNumber = InputHelpers.sprint_name(ARGV[1])
  end
  
  def description
    return "setup #{@sprintNumber}"
  end
  
  
  def run_logged_in
    projects = ['SP', 'BIS', 'CCS', 'CISDTT', 'SYB']

    # Gather the projects with index
    project_versions = projects.collect { | each | self.find_project_version(each) }
    project_versions.each.with_index { | each, idx | puts projects[idx], JSON.pretty_generate(each) unless each.empty? }

    # Nothing to show
    return "#{project_versions.length} versions"
  end

  def find_project_version(project)
    versions = JiraHelpers.versions(project)
    return versions.select { | each | each["name"] == @sprintNumber }
  end
  
end

def get_command
  return Help.new if ARGV.length < 1
  
  ans = case ARGV[0]
  when "login" then Login.new
  when "sprint" then ListSprint.new
  when "dump" then DumpIssue.new
  when "search" then DumpSearch.new
  when "plan" then PlanSprint.new
	when "cust" then CustIssues.new
	when "rank" then ARGV.length > 2 ? RankIssue.new : RankSprint.new
  when "kanban1304" then ListKanban1304.new
  when "create" then CreateSprint.new
  when "start" then StartSprint.new
  when "finish" then FinishSprint.new
  when "move" then ARGV.length > 2 ? MoveIssue.new : MoveSprint.new
  when "session" then SessionValid.new
  when "fix-add" then FixVersionAdd.new
  when "port1304" then ARGV.length > 2 ? ListPortCommits1304.new : ListPort1304.new
  when "report" then ARGV.length > 2 ? TimeReportRange.new : TimeReport.new
  when "benefit" then BeneficiariesReport.new
  when "setup" then SetupSprint.new
  else Help.new
  end

  return ans
end


#
# == Main logic
# 
cmd = get_command

result = cmd.run

if cmd.should_print_result(result)
  puts result
end
