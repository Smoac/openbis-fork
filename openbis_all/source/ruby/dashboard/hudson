#!/usr/bin/env ruby

require 'rubygems'
require 'json'
require 'pp'

#
# = A wrapper for scripting hudson
#

#
# == Preferences
#

# The url for Hudson
$hudson_url = 'http://bs-ci01.ethz.ch:8090'

# The url for the Hudson api
$hudson_api_url = "#{$hudson_url}/api/json"

#
# A module that implements some helpful operations
#
module HudsonHelpers

  # Return summary data for all jobs
  def HudsonHelpers.jobs(silent)
    ans = `curl -s '#{$hudson_api_url}'`
    data = JSON.load(ans)
    return data
  end
  
  # Search and return the full data for the found objects
  def HudsonHelpers.job(job, silent)
    ans = `curl -s '#{$hudson_url}/job/#{job}/api/json'`
    data = JSON.load(ans)
    return data
  end
  
end



#
# == Commands
#

#
# The abstract superclass of commands
# 
class HudsonCommand
  
  attr_accessor :silent
  
  def initialize
    @silent = true
  end
  
  # Return a description of the command to run
  def description
    return nil
  end
  
  # Run the command and return the result
  def run
    return nil
  end

  # Return true if the result should be printed. 
  #
  # Default: print if the result is not empty.
  def should_print_result(result)
    return !result.empty? 
  end
  
  def print_jobs(jobs)
    header = "%24s\t%8s\t%s" % ["Job", "Color", "URL"]
    puts header
    jobs.each do | job |
      row = "%24s\t%8s\t%s" % [job["name"], job["color"], job["url"]]
      puts row
    end
  end
  
end

#
# The help command
#
class Help < HudsonCommand
  def description
    return "help"
  end
  
  def run
    # show help
    return "valid commands: broken, all"
  end
end

#
# The broken command
#
class Broken < HudsonCommand
  def description
    return "broken"
  end
  
  def run
    data = HudsonHelpers.jobs(@silent)
    broken = data["jobs"].select { | each | each["color"] == "yellow" || each["color"] == "red" }
    print_jobs(broken)
    return ""
  end
end


#
# The all command
#
class All < HudsonCommand
  def description
    return "all"
  end
  
  def run
    data = HudsonHelpers.jobs(@silent)
    jobs = data["jobs"].select { | each | each["color"] != "disabled" && each["color"] != "aborted" }
    print_jobs(jobs)
    return ""
  end
end

#
# The job command
#
class Job < HudsonCommand
  
  def initialize
    @job = ARGV[1]
  end
  
  def description
    return "job"
  end
  
  def run
    data = HudsonHelpers.job(@job, @silent)
    return JSON.pretty_generate(data)
  end
end


def get_command
  return Broken.new if ARGV.length < 1
  
  ans = case ARGV[0]
  when "broken" then Broken.new
  when "all" then All.new
  when "job" then Job.new
  else Help.new
  end

  return ans  
end


#
# == Main logic
# 
cmd = get_command

print cmd.description, "\n"

result = cmd.run

if cmd.should_print_result(result)
  puts result
end

print "Done.\n"
