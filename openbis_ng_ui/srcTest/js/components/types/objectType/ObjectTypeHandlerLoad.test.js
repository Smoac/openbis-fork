import ObjectTypeHandlerLoad from '@src/js/components/types/objectType/ObjectTypeHandlerLoad.js'
import ComponentState from '@srcTest/js/common/ComponentState.js'

describe('ObjectTypeHandlerLoadTest', () => {
  test('load success', done => {
    const componentState = new ComponentState({})
    const facade = {
      loadType: jest.fn(),
      loadUsages: jest.fn()
    }

    facade.loadType.mockReturnValueOnce(
      Promise.resolve({
        code: 'TYPE_CODE',
        description: 'TYPE_DESCRIPTION',
        listable: true,
        showContainer: true,
        showParents: true,
        showParentMetadata: true,
        autoGeneratedCode: true,
        generatedCodePrefix: 'TYPE_CODE_PREFIX',
        subcodeUnique: true,
        validationPlugin: { name: 'TYPE_VALIDATION_PLUGIN' },
        propertyAssignments: [
          {
            propertyType: {
              code: 'PROPERTY_0_CODE',
              label: 'PROPERTY_0_LABEL',
              description: 'PROPERTY_0_DESCRIPTION',
              dataType: 'VARCHAR',
              schema: null,
              transformation: null
            },
            plugin: { name: 'PROPERTY_0_PLUGIN' },
            mandatory: true,
            section: 'SECTION_0',
            showInEditView: true,
            showRawValueInForms: true
          },
          {
            propertyType: {
              code: 'PROPERTY_1_CODE',
              label: 'PROPERTY_1_LABEL',
              description: 'PROPERTY_1_DESCRIPTION',
              dataType: 'CONTROLLED_VOCABULARY',
              vocabulary: {
                code: 'PROPERTY_1_VOCABULARY_CODE'
              },
              schema: null,
              transformation: null
            },
            plugin: null,
            mandatory: false,
            section: 'SECTION_0',
            showInEditView: false,
            showRawValueInForms: false
          },
          {
            propertyType: {
              code: 'PROPERTY_2_CODE',
              label: 'PROPERTY_2_LABEL',
              description: 'PROPERTY_2_DESCRIPTION',
              dataType: 'MATERIAL',
              materialType: {
                code: 'PROPERTY_2_MATERIAL_TYPE_CODE'
              },
              schema: null,
              transformation: null
            },
            plugin: null,
            mandatory: false,
            section: null,
            showInEditView: false,
            showRawValueInForms: false
          }
        ]
      })
    )
    facade.loadUsages.mockReturnValueOnce(
      Promise.resolve({
        type: 3,
        property: {
          PROPERTY_0_CODE: 2,
          PROPERTY_1_CODE: 1
        }
      })
    )

    execute(123, componentState, facade).finally(() => {
      expect(facade.loadType).toBeCalledWith(123)
      expect(facade.loadUsages).toBeCalledWith(123)

      const state = componentState.getState()

      delete state.type.original
      state.properties.forEach(property => {
        delete property.original
      })

      componentState.assertState({
        loading: false,
        selection: null,
        sections: [
          {
            id: 'section-0',
            name: 'SECTION_0',
            properties: ['property-0', 'property-1']
          },
          {
            id: 'section-1',
            name: null,
            properties: ['property-2']
          }
        ],
        properties: [
          {
            code: 'PROPERTY_0_CODE',
            dataType: 'VARCHAR',
            description: 'PROPERTY_0_DESCRIPTION',
            errors: {},
            id: 'property-0',
            label: 'PROPERTY_0_LABEL',
            mandatory: true,
            materialType: null,
            plugin: 'PROPERTY_0_PLUGIN',
            schema: null,
            section: 'section-0',
            showInEditView: true,
            showRawValueInForms: true,
            transformation: null,
            usages: 2,
            vocabulary: null
          },
          {
            code: 'PROPERTY_1_CODE',
            dataType: 'CONTROLLED_VOCABULARY',
            description: 'PROPERTY_1_DESCRIPTION',
            errors: {},
            id: 'property-1',
            label: 'PROPERTY_1_LABEL',
            mandatory: false,
            materialType: null,
            plugin: null,
            schema: null,
            section: 'section-0',
            showInEditView: false,
            showRawValueInForms: false,
            transformation: null,
            usages: 1,
            vocabulary: 'PROPERTY_1_VOCABULARY_CODE'
          },
          {
            code: 'PROPERTY_2_CODE',
            dataType: 'MATERIAL',
            description: 'PROPERTY_2_DESCRIPTION',
            errors: {},
            id: 'property-2',
            label: 'PROPERTY_2_LABEL',
            mandatory: false,
            materialType: 'PROPERTY_2_MATERIAL_TYPE_CODE',
            plugin: null,
            schema: null,
            section: 'section-1',
            showInEditView: false,
            showRawValueInForms: false,
            transformation: null,
            usages: 0,
            vocabulary: null
          }
        ],
        type: {
          autoGeneratedCode: true,
          code: 'TYPE_CODE',
          description: 'TYPE_DESCRIPTION',
          errors: {},
          generatedCodePrefix: 'TYPE_CODE_PREFIX',
          listable: true,
          showContainer: true,
          showParentMetadata: true,
          showParents: true,
          subcodeUnique: true,
          usages: 3,
          validationPlugin: 'TYPE_VALIDATION_PLUGIN'
        },
        propertiesCounter: 3,
        sectionsCounter: 2,
        removePropertyDialogOpen: false,
        removeSectionDialogOpen: false
      })

      done()
    })
  })

  test('load failure', done => {
    const componentState = new ComponentState({})
    const facade = {
      loadType: jest.fn(),
      loadUsages: jest.fn(),
      catch: jest.fn()
    }

    facade.loadType.mockReturnValueOnce(Promise.reject('Server unavailable'))
    facade.loadUsages.mockReturnValueOnce(Promise.resolve({}))

    execute(123, componentState, facade).finally(() => {
      expect(facade.loadType).toBeCalledWith(123)
      expect(facade.loadUsages).toBeCalledWith(123)
      expect(facade.catch).toBeCalledWith('Server unavailable')

      componentState.assertState({ loading: false })

      done()
    })
  })
})

const execute = (objectId, componentState, facade) => {
  return new ObjectTypeHandlerLoad(
    objectId,
    componentState.getState(),
    componentState.getSetState(),
    facade
  ).execute()
}
