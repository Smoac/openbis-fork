import _ from 'lodash'
import objectTypes from '@src/js/common/consts/objectType.js'

export default class TypeFormControllerLoad {
  constructor(controller) {
    this.controller = controller
    this.context = controller.context
    this.facade = controller.facade
  }

  async execute() {
    await this.context.setState({
      loading: true,
      validate: false
    })

    return this.load()
      .then(([loadedType, loadedUsages]) => {
        const type = {
          code: _.get(loadedType, 'code', null),
          description: _.get(loadedType, 'description', null),
          listable: _.get(loadedType, 'listable', false),
          showContainer: _.get(loadedType, 'showContainer', false),
          showParents: _.get(loadedType, 'showParents', false),
          showParentMetadata: _.get(loadedType, 'showParentMetadata', false),
          autoGeneratedCode: _.get(loadedType, 'autoGeneratedCode', false),
          generatedCodePrefix: _.get(loadedType, 'generatedCodePrefix', null),
          subcodeUnique: _.get(loadedType, 'subcodeUnique', false),
          validationPlugin: _.get(loadedType, 'validationPlugin.name', null),
          errors: {},
          usages: (loadedUsages && loadedUsages.type) || 0
        }

        const sections = []
        const properties = []
        let currentSection = null
        let currentProperty = null
        let sectionsCounter = 0
        let propertiesCounter = 0

        if (loadedType && loadedType.propertyAssignments) {
          loadedType.propertyAssignments.forEach(assignment => {
            const propertyType = assignment.propertyType
            currentProperty = {
              id: 'property-' + propertiesCounter++,
              code: _.get(propertyType, 'code', null),
              label: _.get(propertyType, 'label', null),
              description: _.get(propertyType, 'description', null),
              dataType: _.get(propertyType, 'dataType', null),
              plugin: _.get(assignment, 'plugin.name', null),
              vocabulary: _.get(propertyType, 'vocabulary.code', null),
              materialType: _.get(propertyType, 'materialType.code', null),
              schema: _.get(propertyType, 'schema', null),
              transformation: _.get(propertyType, 'transformation', null),
              mandatory: _.get(assignment, 'mandatory', false),
              showInEditView: _.get(assignment, 'showInEditView', false),
              showRawValueInForms: _.get(
                assignment,
                'showRawValueInForms',
                false
              ),
              errors: {},
              usages:
                (loadedUsages &&
                  loadedUsages.property &&
                  loadedUsages.property[assignment.propertyType.code]) ||
                0
            }

            if (currentSection && currentSection.name === assignment.section) {
              currentSection.properties.push(currentProperty.id)
            } else {
              currentSection = {
                id: 'section-' + sectionsCounter++,
                name: assignment.section,
                properties: [currentProperty.id]
              }
              sections.push(currentSection)
            }

            currentProperty.section = currentSection.id
            currentProperty.original = {
              ...currentProperty
            }

            properties.push(currentProperty)
          })
        }

        if (loadedType) {
          type.original = {
            ...type,
            properties
          }
        }

        const { selection } = this.context.getState()

        return this.context.setState(() => ({
          type,
          properties,
          propertiesCounter,
          sections,
          sectionsCounter,
          selection: selection ? selection : null,
          removeSectionDialogOpen: false,
          removePropertyDialogOpen: false
        }))
      })
      .catch(error => {
        this.facade.catch(error)
      })
      .finally(() => {
        this.context.setState({
          loading: false
        })
      })
  }

  load() {
    const { id, type } = this.controller.object

    if (type === objectTypes.NEW_OBJECT_TYPE) {
      return Promise.resolve([null, null])
    } else if (type === objectTypes.OBJECT_TYPE) {
      return Promise.all([this.facade.loadType(id), this.facade.loadUsages(id)])
    } else {
      throw 'Unsupported object type: ' + type
    }
  }
}
