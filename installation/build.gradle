evaluationDependsOn(':common')
evaluationDependsOn(':openbis_api')
evaluationDependsOn(':openbis-common')
evaluationDependsOn(':authentication')
evaluationDependsOn(':dbmigration')
evaluationDependsOn(':openbis')
evaluationDependsOn(':datastore_server')
evaluationDependsOn(':rtd_phosphonetx')
evaluationDependsOn(':screening')
evaluationDependsOn(':rtd_yeastx')
evaluationDependsOn(':deep_sequencing_unit')
evaluationDependsOn(':openbis_standard_technologies')

apply from: '../gradle/javaproject.gradle'

// Replace BUILD INFO files for AS and DSS because their revision number is usually to low.
def buildInfo = file("${project.projectDir}/targets/dist/BUILD-${project.name}.INFO").text
file("../datastore_server/targets/dist/BUILD-datastore_server.INFO").write(buildInfo)
file("../openbis_standard_technologies/targets/dist/BUILD-openbis_standard_technologies.INFO").write(buildInfo)

buildscript {
    apply from: '../gradle/repository.gradle'
    
    repositories repositoryConfig
    
    dependencies {
        classpath 'izpack:izpack:+', 
            'apache:commons-io:+',
            'apache:commons-lang:+'
    }
}

dependencies {
    compile project(':common')
    
    compile 'izpack:izpack:+'
    
    testCompile project(path: ':common', configuration: 'tests')
    
    archives 'apache:commons-io:+',
            'apache:log4j:+',
            'cisd:cisd-base:+',
            'postgresql:postgresql:+'
            
}

archivesBaseName = 'openBIS-installation-standard-technologies'
ext.installerDistDir = 'targets/dist/installer'
ext.izPackJar = "${buildDir}/izPack.jar"
println "installerDir:${installerDistDir}"
println "buildDir:${buildDir}"
println "installer:${project.projectDir}/resource/installer"

task copyResources(type: Copy, dependsOn: [compileJava, ':openbis_standard_technologies:zip', ':openbis_standard_technologies:zipDss']) { 
    from "${project.projectDir}/resource/installer"
    from "${project.projectDir}/../openbis_standard_technologies/dist/tarball/installer"
    from zipTree(project(':openbis_standard_technologies').zipDss.archivePath)
    into installerDistDir
    from (zipTree(project(':openbis_standard_technologies').zip.archivePath)) {
        into "openBIS-server"
    }
    def beeReleaseTar = fileTree(dir: 'resource/beewm', include: 'bee-workflowmanager*.gz').getSingleFile()
    def beeRelease = beeReleaseTar.name.replace(".tar.gz","")
    print "bee version: " + beeRelease + "\n"
    from (tarTree(resources.gzip(beeReleaseTar))) {
        into "beewm/"
        exclude '**/etc/*_skeleton'
    }
    from (tarTree(resources.gzip(fileTree(dir: 'resource/beewm', include: 'beewm-democonfig.tar.gz').getSingleFile()))) {
        into "beewm/" + beeRelease + "/etc"
    }
    from (tarTree(resources.gzip('resource/beewm/demo_tool.tgz'))) {
        into "beewm/work"
    }
    from (tarTree(resources.gzip('resource/beewm/bee-openis-plugin.tgz'))) {
        into "core-plugins"
    }
}

// The JAR file created by the IzPack compiler contains folders stored as empty files.
// This is only a problem in gradle environment. The following function fixes this problem by
// removing all empty entries which do not end with '/'.
def fixJarFile = { String jarFilePath ->
    def inputZipFile = new java.util.zip.ZipFile(jarFilePath)
    def zin = null
    def zout = null
    try {
        def entries = inputZipFile.entries()
        def entriesToDelete = new HashSet<String>()
        while (entries.hasMoreElements()) {
            def entry = entries.nextElement()
            if (entry.name.endsWith("/") == false && entry.size == 0) {
                entriesToDelete.add(entry.name)
            }
        }
        zin = new java.util.zip.ZipInputStream(new java.io.FileInputStream(jarFilePath))
        def tmpJarFilePath = jarFilePath + '.tmp'
        zout = new java.util.zip.ZipOutputStream(new java.io.FileOutputStream(tmpJarFilePath))
        byte[] buf = new byte[1024]
        def entry = zin.getNextEntry()
        while (entry != null) {
            if (entriesToDelete.contains(entry.name) == false) {
                zout.putNextEntry(new java.util.zip.ZipEntry(entry.name))
                int len
                while ((len = zin.read(buf)) > 0) {
                    zout.write(buf, 0, len)
                }
            }
            entry = zin.getNextEntry()
        }
        inputZipFile.close()
        zin.close();
        zout.close();
        def jarFile = new File(jarFilePath)
        if (jarFile.delete() == false) {
            throw new IllegalStateException("Couldn't delete ${jarFile}")
        }
        if (new File(tmpJarFilePath).renameTo(jarFile) == false) {
            throw new IllegalStateException("Couldn't rename ${tmpJarFilePath} to ${jarFile}")
        }
    } finally {
        if (inputZipFile != null) {
            inputZipFile.close()
        }
        if (zin != null) {
            zin.close();
        }
        if (zout != null) {
            zout.close();
        }
    }
    
 
}

task(listVersions) << {
    println "project: ${project.name} [${version}]"
    for (p in project.subprojects) {
        println "subproject: ${p.name} [${p.version}]"
    }
}
task(compileInstaller) << {
    def compression = 'default'
    def kind = 'standard'
    def basedir = project.projectDir.path
    def input = '../installation/resource/installer/install.xml'
    def compressionLevel = -1
    def compilerData = new com.izforge.izpack.compiler.data.CompilerData(compression, kind, input, 
            null, basedir, izPackJar, compressionLevel)
    def compilerContainer = new com.izforge.izpack.compiler.container.CompilerContainer()
    compilerContainer.initBindings()
    compilerContainer.addConfig('installFile', input)
    compilerContainer.addComponent(compilerData.class, compilerData)
    def compilerConfig = compilerContainer.getComponent(com.izforge.izpack.compiler.CompilerConfig.class)
    def propertyManager = compilerContainer.getComponent(com.izforge.izpack.compiler.data.PropertyManager.class)
    propertyManager.addProperty('installer.dist.dir', '../installation/' + installerDistDir)
    propertyManager.addProperty('version.number', versionNumber)
    propertyManager.addProperty('revision.number', Integer.toString(revisionNumber))
    compilerConfig.executeCompiler()
    fixJarFile(izPackJar)
}
compileInstaller.dependsOn copyResources

task createInstallerJar(type: Jar, dependsOn: [compileInstaller, jar]) {
    archiveName 'openBIS-installer.jar'
    from zipTree(new File(izPackJar))
    from zipTree(jar.archivePath)
    from zipTree(project(':common').jar.archivePath)
    for (f in configurations.archives.files) {
        from zipTree(f)
    }
    manifest {
        attributes('Main-Class' : 'com.izforge.izpack.installer.bootstrap.Installer')
    }
}

task createInstallerZip(type: Tar, dependsOn: createInstallerJar) {
    compression = Compression.GZIP 
    extension = 'tar.gz'
	baseName 'openBIS-installation-standard-technologies'
	from createInstallerJar.archivePath
	from ('resource/tarball') {
		include 'console.properties'
		include 'extract.sh'
		include 'jul.config'
		include 'run-console.sh'
		include 'run-ui.sh'
	}
	into "openBIS-installation-standard-technologies-${version}"
}

build.dependsOn createInstallerZip
